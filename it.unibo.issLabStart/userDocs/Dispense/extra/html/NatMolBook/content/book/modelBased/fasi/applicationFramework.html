<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<meta name="copyright" content="(C) Copyright 2005" />
<meta name="DC.rights.owner" content="(C) Copyright 2005" />
<meta content="concept" name="DC.Type" />
<meta name="DC.Title" content="Application framework" />
<meta scheme="URI" name="DC.Relation" content="../../../../content/book/modelBased/fasi/sviluppoBottomUp.html" />
<meta content="XHTML" name="DC.Format" />
<meta content="concept" name="DC.Identifier" />
<meta content="en-us" name="DC.Language" />
<link href="../../../../css/commonltr.css" type="text/css" rel="stylesheet" />
<title>Application framework</title>
</head>
<body id="concept"><a name="concept"><!-- --></a>


<h1 class="topictitle1">Application framework</h1>

<div>
<p>
Supponendo di applicare ripetutamente il principio della separazione 
con riferimento a molte applicazioni
in un dato dominio, si giunge alla individuziaone non tanto di un
framework general purpose quale <tt>J2EE</tt> o <tt>.NET</tt> 
quanto ad un <em>application framework</em>.

Oltre ai vantaggi che scaturisono da una organizzazione a componenti,
l'uso di un application framework risulta vantaggioso in quanto propone e supporta
un insieme di <em>astrazioni riusabili</em> per una intera
famiglia di prodotti.
</p>
<p>
Lo sviluppo di un application framework scaturisce
nella <em>fase di consolidamento</em> di un'applicazione [Foote92] 
quando si effettua un refactoring del software per migliorare
l'organizzazione senza modificare il funzionamento (osservabile).
Questo può essere fatto da uno stesso team che sviluppa più applicazioni
in successione o da team diversi che sviluppano in parallelo
[RJ96]. 
Il secondo approccio è più oneroso sia in tempo che in risorse,
ma permette di esercitare prospettive diverse, migliorando
la generalità delle astrazioni riusabili che si possono individuare.
</p>
<p>

L'interesse a definire una <em>famiglia di prodotti</em> può nascere
da parte di <em>System Integrators</em> (SI) nel portare una stessa applicazione 
a più clienti, o da parte da <em>Independent Software Vendors</em> (ISV) nello
sviluppo di diverse applicazioni in specifici domini come ad esempio
CRM (<em>Costumer Relationship Management</em>) o da parte di organizzazioni IT
ad esempio nel predisporre versioni multiple di un'applicazione
attraverso maintenance ed enhancement. 
</p>
<p>
Un application framework tuttavia non può essere definito una volta per tutte;
il dominio applicativo presenterà inevitabilmente nuove forze o nuove prospettive
per cui occorre rimettere mano alla parte architetturale comune.
Inoltre vi possono essere retroazioni (feedback) sul framework da parte di coloro che sviluppano le
applicazioni che possono indurre a un refactoring del framework stesso.
</p>
<p>
D'altra parte un application framework deve essere quanto più stabile possibile
in quanto mira a  supportare l'unione dei requisiti di un intero
dominio applicativo.
Per ottenere questo obiettivo puà essere opportuno usare <em>metodi agili</em> 
(si veda <a href="../../processi/ProcessiAgili.html">Processi agili</a>)
che permettano
un continuo refactoring preservando l'integrità architetturale del framework
e un collaudo continuo al variare dei requisiti supportati (per non
compromettere l'integrità delle applicazioni).
Nella progettazione e sviluppo di un framework i pattern (languages)
svolgono un ruolo
molto importante per individuare le alternative di progettazione
che permettono di raggiungere specifiche proprietà, prima tra tutte la
riusabilità, e per ridurre i costi dei cambiamenti minimizzando
i loro effetti.

</p>


<div class="section"><h2 class="sectiontitle">Framework-based development</h2>
<p>
La possibilità di disporre di un application framework modifica ulteriormente
il processo di produzione del software in quanto lo sviluppo di un'applicazione
nel dominio del framework avviene di fatto in modo molto più vincolato rispetto all'uso
di una piattaforma general purpose: il framework, imponendo un preciso stile
architetturale, ha di fatto già "risolto" un importante
insieme delle forze che caratterizzano
quel dominio, riducendo la complessità del problema agli occhi sia dell'analista
sia del progettista, che possono ora meglio concentrarsi sulla "business logic" del problema.
</p>
<p>
Una parte rilevante della complessità della costruzione
del software si traduce ora nella produzione/gestione dei diversi artefatti
relativi  ai punti di flessibilità (<em>variation points</em>) previsti dal framework per
permettere l'adattamento ai requisiti della specifica applicazione.
Questa complessità viene ridotta dall'uso di appositi tools; altri tools
possono aiutare nella produzione di artefatti di deployment che possono essere
assemblati, configurati e packaged per produrre <em>executables</em> da
replicare, installare, registrare, etc. su piattaforme
target quali applications servers, database servers, messaging systems,
transaction monitors, web services, etc.
</p>

</div>


 
</div>

<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="../../../../content/book/modelBased/fasi/sviluppoBottomUp.html">Sviluppo bottom-up</a></div>
</div>
</div>

</body>
</html>