
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

    <title>Costruire software &#8212; iss22 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="WorkspaceSetup" href="WorkspaceSetup.html" />
    <link rel="prev" title="Introduzione" href="Introduzione.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="costruire-software">
<h1>Costruire software<a class="headerlink" href="#costruire-software" title="Permalink to this headline">¶</a></h1>
<p>Il software puo essere definito come:</p>
<ul class="simple">
<li><p>l’insieme di <em>frasi espresse in un qualche linguaggio formale</em> al fine di istruire un elaboratore
o una rete di elaboratori,</p></li>
</ul>
<p>Il <span class="blue">software non ha consistenza fisica</span>; può consumare energia ed altre risorse,
produrre effetti utili o dannosi, avere conseguenze rilevanti sul piano economico e sociale,
ma il software è del tutto privo di massa.</p>
<p>Le conseguenze di questa caratteristica sono molteplici, sia sul piano pragmatico che sul piano filosofico.
Limitando il discorso al contesto della produzione industriale, si è diffusa la convinzione che
la costruzione del software non richieda, per sua natura, processi di produzione tipici dell’ingegneria tradizionale.</p>
<a class="reference internal image-reference" href="_images/ScienzaEIng.PNG"><img alt="_images/ScienzaEIng.PNG" class="align-center" src="_images/ScienzaEIng.PNG" style="width: 80%;" /></a>
<p>Per meglio comprendere questa differenza e anche la profonda relazione tra scienza e ingegneria
possiamo riflettere sul seguente problema:</p>
<p><span class="remark">costruire un sistema software che operi come una mente unama</span></p>
<section id="ingegneria">
<h2>Ingegneria<a class="headerlink" href="#ingegneria" title="Permalink to this headline">¶</a></h2>
<p>Nell’<strong>ingegneria tradizionale</strong> (meccanica, edile, etc) il costo del materiale costituisce spesso più del 50%
del costo totale di un progetto, mentre nella produzione del software è il costo del lavoro ad essere preponderante:
si parte dal 70% fino a giungere quasi al 100%.</p>
<p>L’ingegneria tradizionale ha anche sperimentato che un cambiamento
di costo 1 in fase di analisi potrebbe costare 1000 in fase di produzione.</p>
<p>Per questo l’ingegneria classica diversifica le fasi di produzione delineando un ben noto flusso di lavoro
(<em>workflow</em>) costituito da un insieme di passi (o tasks):</p>
<ol class="arabic simple">
<li><p>definizione dei requisiti,</p></li>
<li><p>analisi del problema,</p></li>
<li><p>progetto della soluzione,</p></li>
<li><p>realizzazione del prodotto,</p></li>
<li><p>collaudo</p></li>
<li><p>messa in opera</p></li>
</ol>
<p>spesso eseguiti uno dopo l’altro, in un classico <span class="blue">processo di sviluppo sequenziale o a cascata</span>.</p>
<a class="reference internal image-reference" href="_images/WaterFall.PNG" id="waterfall"><img alt="_images/WaterFall.PNG" class="align-center" id="waterfall" src="_images/WaterFall.PNG" style="width: 80%;" /></a>
</section>
<section id="programmatori-non-ingegneri">
<h2>Programmatori = (non) ingegneri?<a class="headerlink" href="#programmatori-non-ingegneri" title="Permalink to this headline">¶</a></h2>
<p>Nella produzione industriale del software è piuttosto comune cercare di abbattere i costi
di progetto e di sviluppo, anche limitando le dimensioni del gruppo di lavoro.
Spesso si cerca anche di aggredire il mercato prefissando una data di distribuzione del prodotto, che viene di frequente
rilasciato non completamente finito, accollando all’utente parte dell’onere di collaudo.</p>
<p>Sotto la spinta di stringenti vincoli di <em>time to market</em> (<strong>TTM</strong>) molte aziende adottano uno schema del tipo
<span class="blue">“scrivi, prova e correggi”</span>, mirando alla produzione di codice al minor “costo immediato” possibile.
Le <span class="blue">fasi di analisi e progetto</span> anche se accuratamente svolte, non sempre sono adeguatamente documentate,
e <em>quasi mai corralete in modo sistematico con il codice prodotto</em>.</p>
<section id="sviluppo-bottomup">
<h3>Sviluppo bottomUp<a class="headerlink" href="#sviluppo-bottomup" title="Permalink to this headline">¶</a></h3>
<p>Il processo di costruzione del sofware è quindi <span class="blue">influenzato da una potente forza</span>,
legata alla natura stessa del software: la spinta a impostare la costruzione  in modo <strong>bottom-up</strong>,
a partire da una specifica tecnologia costituita da un linguaggio di programmazione,
o da un framework applicativo o da una piattafforma operativa.</p>
<a class="reference internal image-reference" href="_images/bottomUp.png" id="bottomup"><img alt="_images/bottomUp.png" class="align-center" id="bottomup" src="_images/bottomUp.png" style="width: 50%;" /></a>
<p>La principale conseguenza negativa di questa forza è molto spesso la mancata valutazione di alternative tecnologiche
in fase di analisi del problema e l’assenza di una esplicita descrizione di progetto
che permetta di anticipare la valutazione dei rischi e le potenziali difficoltà connesse allo sviluppo.
In molti casi adeguate fasi di analisi e di progettazione hanno luogo, anche in modo sistematico;
ma ciò putroppo quasi sempre accade <strong>solo nella mente dei programmatori</strong>;
nel codice finale non vi è più traccia alcuna di queste fasi, se non qualche debole segnale legato a sporadici commenti.</p>
<p>Tuttavia, anche se il codice fosse accuratamente documentato, sia in relazione all’analisi, sia in relazione
alle scelte di progetto, la <strong>riduzione del prodotto al solo codice sarebbe non accettabile</strong>,
se non nel caso di sistemi software semplici o di software molto ben fatto.</p>
<p>All’aumentare della complessità infatti, la <span class="blue">mente umana ha bisogno</span>,
per comprendere, di decomporre il problema in parti di ampiezza limitata,
<span class="blue">articolando la descrizione in livelli di astrazione diversi</span>;
poiché il codice deve inevitabilmente esprimere il sistema finale nei suoi minimi dettagli,
la maggior parte delle persone sarebbe incapace di leggerlo con profitto anche se a conoscenza
delle regole sintattiche del linguaggio di programmazione.</p>
<p>Per questo si parla spesso di <strong>modelli</strong>, che vengono espressi con opportuni linguaggi, di solito in forma grafica.</p>
</section>
</section>
<section id="modelli">
<h2>Modelli<a class="headerlink" href="#modelli" title="Permalink to this headline">¶</a></h2>
<p>Nel linguaggio comune, il termine modello è spesso usato per denotare un’astrazione
di qualcosa che esiste nella realtà, come ad esempio il modello che posa per un artista,
una riproduzione in miniatura, un esempio di modo di svolgere un’attività, una forma
da cui ricavare vestiti, un ideale da seguire, etc..</p>
<p>Alcuni (tra cui gli ingegneri) intendono per modello un sistema matematico o fisico che ubbidisce
a specifici vincoli e che può essere utilizzato per descrivere e comprendere un sistema
(fisico, biologico, sociale, etc.) attraverso relazioni di analogia.</p>
<p>Nel contesto dei processi di costruzione del software, il termine modello va primariamente
inteso come un insieme di concetti e proprietà volti a catturare aspetti essenziali di un sistema,
collocandosi in un preciso spazio concettuale.</p>
<a class="reference internal image-reference" href="_images/Modello.PNG"><img alt="_images/Modello.PNG" class="align-center" src="_images/Modello.PNG" style="width: 60%;" /></a>
<p>Per l’ingegnere del software quindi un modello costituisce una visione semplificata di un sistema
che rende il sistema stesso più accessibile alla comprensione e alla valutazione e facilita
il trasferimento di informazione e la collaborazione tra persone,
soprattutto quando è espresso in forma visuale.</p>
<a class="reference internal image-reference" href="_images/ModelloNumeri.PNG"><img alt="_images/ModelloNumeri.PNG" class="align-center" src="_images/ModelloNumeri.PNG" style="width: 50%;" /></a>
<p>Nel concepire un modello come visione semplificata di un sistema software si assume che il sistema
abbia già una sua esistenza concreta.
In alcune fasi di lavoro (in particolare nella fase di analisi) il sistema è il modello;
un raffinamento o una variazione del modello corrisponde in questo caso ad una variazione del sistema.</p>
<p>La produzione esplicita di modelli si rivela utile in quanto i diversi attori di un processo
di produzione di software (committenti, analisti, progettisti, utenti, etc)
operano a diversi livelli di astrazione e con fini diversi.</p>
<p>Definendo opportuni modelli del sistema da realizzare, in ogni fase del processo di produzione
l’attenzione può essere focalizzata sugli aspetti rilevanti in quella fase, utilizzando una
forma di comunicazione comprensibile ad attori diversi.
Per garantire coesione e interoperabilità, si cerca di individuare regole di corrispondenza
e di trasformazione automatica tra modelli.</p>
</section>
<section id="la-crisi-del-software">
<h2>La crisi del software<a class="headerlink" href="#la-crisi-del-software" title="Permalink to this headline">¶</a></h2>
<p>Impostare un processo di produzione in assenza di descrizioni del sistema che permettano di
<span class="blue">anticipare la valutazione dei rischi</span>
espone il processo stesso a un potenziale fallimento;
non meraviglia dunque che si senta spesso parlare di <strong>crisi del software</strong>.</p>
<p>La letteratura  (si veda ad esempio <a class="reference external" href="https://www.rankred.com/biggest-software-failures/">SEDisasters</a>) riporta casi di fallimento di un numero
sorprendentemente rilevante di progetti software, evidenziando un insieme di cause principali:</p>
<ul class="simple">
<li><p>Cattiva specifica e gestione dei requisiti.</p></li>
<li><p>Comunicazioni ambigue ed imprecise tra i diversi attori del processo di produzione
(utenti, manager, analisti, progettisti, implementatori).</p></li>
<li><p>Architetture finali del sistema fragili (non robuste).</p></li>
<li><p>Inconsistenze tra requisiti, progetto e realizzazione.</p></li>
<li><p>Collaudi inadeguati o insufficienti.</p></li>
<li><p>Inadeguata capacità di valutare e gestire i rischi e di controllare la propagazione dei cambiamenti.</p></li>
</ul>
<p>Queste potenziali fonti di insuccesso hanno amplificato la loro influenza nel momento in cui
l’intera disciplina ha vissuto la <span class="blue">transizione</span> da una dimensione prevalentemente <span class="blue">algoritmico-trasformazionale</span>
a un dimensione fortemente <span class="blue">sistemistico-architetturale</span>.</p>
</section>
<section id="richiami">
<h2>Richiami<a class="headerlink" href="#richiami" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="./NatMolBook/bookEntry.html">Dispense Ingegneria del software</a></p>
</section>
<section id="il-ruolo-dell-architettura">
<h2>Il ruolo dell’architettura<a class="headerlink" href="#il-ruolo-dell-architettura" title="Permalink to this headline">¶</a></h2>
<p>La moderna costruzione del software riconosce all’architettura del sistema un ruolo strategico,
nonostante il termine <em>architettura</em> sia tra i vocaboli più sovraccarichi di significato.</p>
<p>Normalmente, si parla di <span class="blue">architettura di un sistema</span> quando ci si vuole riferire all’insieme delle
macro-parti in cui il sistema si articola, includendo le loro responsabilità, relazioni e interconnessioni.</p>
<p>Per molti, il termine <em>architettura</em> potrebbe però evocare l’immagine di uno schema in cui compare una rete
di blocchi e linee di connessione; questa visione andrebbe meglio indicata col termine <strong>mappa</strong>.</p>
<p>Per altri, l’<em>architettura</em> evoca l’idea di uno schema concettuale di soluzione riferito a un certo dominio applicativo,
come ad esempio nella frase <em>architetture web</em>; in questo caso sarebbe più appropriato utilizzare il termine <strong>framework</strong>.</p>
<p>L’ Open Group Architectural Framework (<a class="reference external" href="https://it.wikipedia.org/wiki/The_Open_Group_Architecture_Framework">OpenGroupArch</a>) definisce architettura:</p>
<ul class="simple">
<li><p>“a set of elements depicted in an architectural model and a specification of how these elements are connected
to meet the overall requirements of an information system”.</p></li>
</ul>
<p>Altrove  si dice che:</p>
<ul class="simple">
<li><p>“the software architecture of a program or computing system is the structure
or structures of the system, which comprises software components, the externally-visible properties
of these components and the relationships among them”.</p></li>
</ul>
<p>La IEEE Computer society definisce (nel 2000) l’architettura:</p>
<ul class="simple">
<li><p>“the fundamental organization of a
system embodied in its components their relationships to each other and to the environment,
and the principles guiding its design and evaluation”.</p></li>
</ul>
<p>Tra le altre accezioni possibili, una delle più curiose, su cui vale la pena di riflettere, è quella per cui:</p>
<blockquote>
<div><ul class="simple">
<li><p>l’architettura è ciò che rimane di un sistema quando non si può più togliere nulla,
continuando a comprenderne la struttura e il funzionamento.</p></li>
</ul>
</div></blockquote>
<p>Le prime esperienze collettive nello studio delle architetture software possono essere fatte
risalire al workshop OOPSLA del 1981 guidato da Bruce Anderson che mirava allo sviluppo
di un “architecture handbook”.</p>
<section id="design-patterns">
<h3>Design patterns<a class="headerlink" href="#design-patterns" title="Permalink to this headline">¶</a></h3>
<p>Agli anni 90 del secolo scorso può anche essere fatto risalire l’idea di <span class="blue">pattern</span>, culminata nella pubblicazione
nel 1995 dell’ormai famoso testo sui <a class="reference external" href="https://it.wikipedia.org/wiki/Design_pattern">Design Pattern</a>  della così detta
<strong>GoF</strong> (<em>Gang-of-Four</em>: <em>Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides</em>).</p>
<a class="reference internal image-reference" href="_images/DesignPatternGof.PNG"><img alt="_images/DesignPatternGof.PNG" class="align-center" src="_images/DesignPatternGof.PNG" style="width: 80%;" /></a>
<p>Da allora si sono susseguiti molte altre conferenze e lavori.
I riferimenti più noti sono i cinque testi POSA (si veda in <a class="reference external" href="_static/books.html">libri</a> ) sulle <em>Pattern oriented Software Architectures</em>
e i convegni PLoP (<em>Pattern Languages of Programming</em>).</p>
<a class="reference internal image-reference" href="_images/Posa.PNG"><img alt="_images/Posa.PNG" class="align-center" src="_images/Posa.PNG" style="width: 80%;" /></a>
</section>
</section>
<section id="dimensioni">
<h2>Dimensioni<a class="headerlink" href="#dimensioni" title="Permalink to this headline">¶</a></h2>
<p>Sia nella fase di analisi che in quella di progetto, la descrizione di un sistema software può avvenire
focalizzando l’attenzione su almeno tre diversi punti di vista:</p>
<ul class="simple">
<li><p>l’organizzazione del sistema in parti (<strong>struttura</strong>);</p></li>
<li><p>il modo in cui le diverse parti scambiano informazione implicita o esplicita tra loro (<strong>interazione</strong>);</p></li>
<li><p>il funzionamento del tutto e di ogni singola parte (<strong>comportamento</strong>).</p></li>
</ul>
<a class="reference internal image-reference" href="_images/Dimensioni.png"><img alt="_images/Dimensioni.png" class="align-center" src="_images/Dimensioni.png" style="width: 80%;" /></a>
<p>Questi punti di vista costituiscono tre indispensabili dimensioni in cui articolare lo spazio della descrizione
del sistema, qualunque sia il linguaggio utilizzato per esprimere questa descrizione.</p>
<section id="struttura">
<h3>Struttura<a class="headerlink" href="#struttura" title="Permalink to this headline">¶</a></h3>
<p>Dal punto di vista strutturale, le <em>funzioni</em> (o le <em>procedure</em>) e gli <em>oggetti</em> costituiscono componenti fondamentali,
largamente in uso  nei programmi non distribuiti, anche di piccole dimensioni.
Nel seguito,  cercheremo di rappresentare ciascuno di essi con una forma grafica convenzionale, come ad esempio:</p>
<a class="reference internal image-reference" href="_images/legendBasicComponents.PNG"><img alt="_images/legendBasicComponents.PNG" class="align-center" src="_images/legendBasicComponents.PNG" style="width: 25%;" /></a>
<p>Nel contesto di un sistema software distribuito, componenti-base come le funzioni si trovano all’interno di altri
componenti, che possiamo qui indicare genericamente come  <span class="blue">macro-componenti</span>.
Anche per questi, è opportuno introdurre una forma grafica convenzionale, come, ad esempio:</p>
<a class="reference internal image-reference" href="_images/legendComponets.PNG"><img alt="_images/legendComponets.PNG" class="align-center" src="_images/legendComponets.PNG" style="width: 25%;" /></a>
<p>Per impostare in modo sistematico la definizione a livello strutturale di un sistema è conveniente,
sia in fase di analisi sia in fase di progetto, cercare di dare risposta ad alcune domande relative alla natura
dei suoi componenti, quali ad esempio:</p>
<ul class="simple">
<li><p>il componente è <span class="blue">attivo</span> (dotato di un proprio flusso di controllo)? Se il componente non ha
flusso di controllo autonomo, noi diremo che è un <span class="blue">oggetto</span>.</p></li>
<li><p>il componente è <span class="blue">atomico o composto</span>? Nel caso sia composto quali sono le parti che lo formano?</p></li>
<li><p>il componente è dotato di <span class="blue">stato modificabile</span>? In caso affermativo, quali sono le operazioni di modifica dello stato?</p></li>
<li><p>quali <span class="blue">proprietà (attributi)</span> caratterizzano il componente?</p></li>
<li><p>da quali altri componenti dipende e secondo quale <span class="blue">tipo di dipendenza</span>?</p></li>
</ul>
<p>Si noti che un componente non atomico implica la <em>definizione ricorsiva della struttura di ogni parte</em> e
la definizione di operazioni denominate <strong>selettori</strong> che forniscono (riferimenti a) i componenti costituenti.</p>
</section>
<section id="interazione">
<h3>Interazione<a class="headerlink" href="#interazione" title="Permalink to this headline">¶</a></h3>
<p>Le interazioni tra <strong>oggetti</strong> avvengono tramite <span class="blue">procedure-call</span>, cioè a trasferimento di controllo.</p>
<p>Le interazioni tra <strong>componenti attivi</strong> possono avvenire trameite <span class="blue">oggetti condivisi</span>, allocati su memoria comune,
oppure tramite <span class="blue">messaggi</span> che riguardano <em>informazioni</em> o <em>stream di dati</em> e che possono essere scambiati
in forma sincrona, asincrona o isocrona.</p>
<p>In una interazione <strong>asincrona</strong>, la comunicazione è “bufferizzata” senza alcuna
limitazione sulle dimensioni del buffer.
L’emittente non deve attendere alcuna informazione di ritorno anche quando invia informazione
ad uno specifico destinatario. Il ricevente attende solo quando il buffer è vuoto.
Nel caso di stream, non vi sono vincoli di tempo per la ricezione.</p>
<p>In una interazione <strong>sincrona</strong>, la comunicazione avviene senza l’uso di alcun buffer.
L’emittente e il desinatario scambiano informazione unificando concettualmente le proprie attività.
Nel caso di stream, il destinatario si aspetta di ricevere i dati con un ritardo (delay)
che non supera un massimo prefissato.</p>
<p>Una interazione <strong>isocrona</strong> riguarda solo stream; il destinatario si aspetta di ricevere i dati
con un delay compreso tra un minimo e un massimo.</p>
<p>Le interazioni a messaggi vengono anche spesso suddivise secondo quattro pattern principali:</p>
<ul class="simple">
<li><p><strong>Fire and forget</strong>: il caso di invio di  messaggi.</p></li>
<li><p><strong>Sync with server</strong>: il caso request-response.</p></li>
<li><p><strong>Poll objects</strong>: il sender invia una request delegando ad un oggetto (<em>poll object</em>) la responsabilità
di ricevere la risposta. Il sender usa il poll object per verificare ed acquisire la disponibilità della risposta.</p></li>
<li><p><strong>Result callback</strong>: il sender invia una request specificando un oggetto (<em>callback object</em>) che implementa
un metodo che verrà invocato dal supporto non appena il receiver invierà la risposta.</p></li>
</ul>
<p>Torneremo diffusamente su questi punti, che costituiscono il cuore del passaggio da OOP a message-passing.</p>
<section id="terminologia-di-riferimento">
<h4>Terminologia di riferimento<a class="headerlink" href="#terminologia-di-riferimento" title="Permalink to this headline">¶</a></h4>
<p>Nel seguito, faremo riferimento alla seguente terminologia:</p>
<ul class="simple">
<li><p><strong>Messaggio</strong> (<span class="blue">message</span>): termine generico per denotare informazione scambiata mediante
l’uso di un opportuno supporto di comunicazione.</p></li>
<li><p><strong>Dispaccio</strong> (<span class="blue">dispatch</span>): messaggio inviato in modo asincrono a N (N&gt;=1) specifici destinatari,
noti alla emittente, con l’aspettativa che questi lo ricevano e lo elaborino; l’emittente non si aspetta
alcuna informazione di ritorno.</p></li>
<li><p><strong>Invito</strong> (<span class="blue">invitation</span>): messaggio inviato a N (N&gt;=1) destinatari, con l’aspettativa che almeno uno lo riceva
e invii al mittente un messaggio di <em>conferma</em>.</p></li>
<li><p><strong>Conferma</strong> (<span class="blue">ack</span>): messaggio inviato al mittente di un <em>invitation</em>.
Il contenuto del messaggio rappresenta un riconoscimento di avvenuta ricezione.</p></li>
<li><p><strong>Richiesta</strong> (<span class="blue">request</span>): messaggio inviato a uno specifico destinatario; il contenuto del messaggio
rappresenta la richiesta di esecuzione di una attività, con aspettativa da parte del mittente
che questa attività si concluda con una risposta pertinente alla richiesta.</p></li>
<li><p><strong>Risposta</strong> (<span class="blue">reply, response</span>): messaggio inviato da un destinatario al mittente di una richiesta.
il contenuto del messaggio rappresenta informazione pertinente alla richiesta.</p></li>
<li><p><strong>Evento</strong> (<span class="blue">event</span>): messaggio emesso (più o meno consapevolmente) in modo asincrono da una sorgente
senza alcuna particolare nozione di destinatario e senza alcuna aspettativa da parte dell’emittente.</p></li>
<li><p><strong>Segnale</strong> (<span class="blue">signal</span>): messaggio emesso in modo consapevole e asincrono a N (N&gt;=1) destinatari,
noti o meno all’emittente,
con l’aspettativa che venga ricevuto da qualcuno, al fine di eseguire un’azione che potrebbe portare vantaggio
all’emittente, al ricevente e/o al sistema nel suo complesso.</p></li>
</ul>
<p>Per denotare in forma grafica questi diversi tipi di messaggi, faremo riferimento a simboli come quelli della figura che segue:</p>
<a class="reference internal image-reference" href="_images/legendMessages.PNG"><img alt="_images/legendMessages.PNG" class="align-center" src="_images/legendMessages.PNG" style="width: 25%;" /></a>
</section>
<section id="un-problema-applicativo">
<h4>Un problema ‘applicativo’<a class="headerlink" href="#un-problema-applicativo" title="Permalink to this headline">¶</a></h4>
<p><span class="worktodo">WORKTODO: Request after a request</span></p>
<ul>
<li><p>Discutere la forma di interazione in cui un componente A invia una <em>request</em> X a un componente B e questi risponde
solo dopo avere ricevuto da A la risposta a una sua <em>request</em> Y.</p>
<p>Esempio: A chiede a B di inviargli la fattura di un ordine ma non gli dice a quale indirizzo, per cui B lo chiede ad A
prima di rispondergli con il documento richiesto.</p>
</li>
</ul>
</section>
</section>
<section id="comportamento">
<h3>Comportamento<a class="headerlink" href="#comportamento" title="Permalink to this headline">¶</a></h3>
<p>Per esprimere il comportamento di un componente software, si distinguono classicamente tre diversi ‘stili’:</p>
<ul class="simple">
<li><p>imperativo</p></li>
<li><p>funzionale</p></li>
<li><p>logico-dichiarativo</p></li>
</ul>
<p>Il funzionamento di un componente comporta spesso l’individuazione
di un insieme di <strong>operazioni primitive</strong>, sulla base delle quali costruire ogni altra operazione
di manipolazione/gestione del componente.</p>
<p>Si pensi per esempio al caso di un <em>oggetto lista</em>, le cui primitive
sono il costruttore <code class="docutils literal notranslate"><span class="pre">cons</span></code>, i selettori <code class="docutils literal notranslate"><span class="pre">head,</span> <span class="pre">tail</span></code> e il predicato <code class="docutils literal notranslate"><span class="pre">empty</span></code>. Un volta data la lista vuota (l’oggetto <code class="docutils literal notranslate"><span class="pre">emptyList</span></code>)
ogni lista può essere costruita e manipolata attraverso l’uso di queste primitive.</p>
<p>Spesso si qualifica il comportamento di un componente facendo riferimento a tipi diversi di <strong>macchine astratte</strong>, iniziando dalla
<a class="reference external" href="https://plato.stanford.edu/entries/turing-machine/">Turing Machine</a> (<strong>TM</strong>), che individua,
in stile imperativo, le mosse-base (<em>primitive</em>) di un automa che permette di realizzare qualunque calcolo.</p>
<a class="reference internal image-reference" href="_images/TuringMachine.PNG"><img alt="_images/TuringMachine.PNG" class="align-center" src="_images/TuringMachine.PNG" style="width: 60%;" /></a>
<p>Si veda <a class="reference external" href="https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html">Raspberry Pi TM</a></p>
<p>Un automa equivalente che ottiene lo stesso risultato con una sorta di <a class="reference external" href="https://it.wikipedia.org/wiki/Linguaggio_assembly">Linguaggio assembly</a> minimale è la
<a class="reference external" href="https://en.wikipedia.org/wiki/Counter_machine">Minsky Machine</a> (nota anche come <em>Counter Machine</em>):</p>
<a class="reference internal image-reference" href="_images/MinskyMachine.PNG"><img alt="_images/MinskyMachine.PNG" class="align-center" src="_images/MinskyMachine.PNG" style="width: 60%;" /></a>
<p>Un tipo meno potente di macchina astratta rispetto alla <strong>TM</strong> è il <a class="reference external" href="https://it.wikipedia.org/wiki/Automa_a_pila">pushdown automaton</a> (<strong>PDA</strong>) che però è l’automa
di riferimento per il riconoscimento delle frasi di un inguaggio con <em>sintassi context-free</em>, di tipo 2 nella
<a class="reference external" href="https://it.wikiversity.org/wiki/Classificazione_delle_grammatiche">gerarchia di Chomsky</a> .</p>
<section id="automi-a-stati-finiti">
<h4>Automi a stati finiti<a class="headerlink" href="#automi-a-stati-finiti" title="Permalink to this headline">¶</a></h4>
<p>Un ulteriore tipo di automa meno potente della TM, ma su cui si fonda sia la TM sia il PDA
è l’<a class="reference external" href="https://it.wikipedia.org/wiki/Automa_a_stati_finiti">Automa a stati finiti</a> (<em>Finite State Machine</em> - <strong>FSM</strong>)
il cui funzionamento può essere formalmente descritto da una 5-tuple (<code class="docutils literal notranslate"><span class="pre">States,</span> <span class="pre">Inputs,</span> <span class="pre">Outputs,</span> <span class="pre">Transitions,</span> <span class="pre">InitialState</span></code>):</p>
<ul>
<li><p><strong>States</strong>: insieme di possibili stati in cui l’automa si può trovare.</p></li>
<li><p><strong>Inputs</strong>: insieme delle informazioni di ingresso, denotabili attraverso un <em>input alphabet</em>; nel nostro caso
possiamo pensare che ogni simbolo dell’alfabeto  denoti un messggio.</p></li>
<li><p><strong>Outputs</strong>: insieme della informazioni di uscita, denotabili attraverso un <em>output alphabet</em>;   nel nostro caso
possiamo pensare che ogni simbolo dell’alfabeto denoti una <strong>azione</strong>.</p></li>
<li><p><strong>InitialState</strong>: lo stato iniziale (unico) in cui l’automa si trova quando viene creato.</p></li>
<li><p><strong>Transizione</strong>: definisce il nuovo stato e l’output dell’automa in funzione dello stato corrente e del simbolo corrente in ingresso.
E’ spesso espressa da una coppia di funzioni:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nextState</span><span class="p">:</span>      <span class="n">States</span> <span class="n">x</span> <span class="n">Inputs</span> <span class="o">-&gt;</span> <span class="n">States</span>
<span class="n">output</span><span class="p">:</span>         <span class="n">States</span> <span class="n">x</span> <span class="n">Inputs</span> <span class="o">-&gt;</span> <span class="n">Outputs</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<p>Normalmente, gli automi a stati finiti si suddividono in due grandi categorie:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Mealy_machine">MealyMachines</a>: una FSM il cui output è determinato sia dallo stato corrente sia dall’input corrente.</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Moore_machine">MooreMachines</a>: una FSM il cui output dipende unicamente dallo stato corrente (<code class="docutils literal notranslate"><span class="pre">SCUR</span></code>) in cui l’automa si trova.</p></li>
</ul>
<p><strong>FSM</strong> di tipo  <a class="reference external" href="https://en.wikipedia.org/wiki/Moore_machine">MooreMachines</a> avranno per noi un ruolo fondamentale.
Quando l’automa si trova nello stato corrente <code class="docutils literal notranslate"><span class="pre">SCUR</span></code>:</p>
<ol class="arabic simple">
<li><p>esegue una sequenza (che <strong>deve terminare</strong>) di azioni;</p></li>
<li><p>al termine della sequenza di azioni controlla che vi sia almeno un input (messaggio)
capace di attivare una delle transizioni verso un ulteriore stato (<code class="docutils literal notranslate"><span class="pre">SNEXT</span></code>);</p></li>
<li><p>attiva una delle transizioni possibili pasando dallo stato <code class="docutils literal notranslate"><span class="pre">SCUR</span></code> allo stato <code class="docutils literal notranslate"><span class="pre">SNEXT</span></code> (che potrebbe anche coincidere
con <code class="docutils literal notranslate"><span class="pre">SCUR</span></code>);</p></li>
<li><p>se non vi sono transizioni attivabili, rimane nello stato <code class="docutils literal notranslate"><span class="pre">SCUR</span></code> da cui potrà sbloccarsi solo in conseguenza di un
ulteriore messaggio di input.</p></li>
</ol>
</section>
</section>
<section id="linguaggi">
<h3>Linguaggi<a class="headerlink" href="#linguaggi" title="Permalink to this headline">¶</a></h3>
<p>Costrutti per esprimere strutture (di dati e di controllo), forme di comportamento e meccanismi di interazione
sono presenti in tutti i <a class="reference external" href="https://it.wikipedia.org/wiki/Linguaggio_di_programmazione">Linguaggi di programmazione</a>.</p>
<p>Un punto importante consiste nel capire fino a che punto i costrutti di un linguaggio debbano influenzare
il progettista (se non lo stesso analista).
Fino alla fine degli anni 90 il linguaggio di programmazione è stato il veicolo principale per introdurre
nuovi concetti sia sul piano computazionale sia sul sul piano della organizzazione del software.</p>
<p>La figura che segue mostra una visione sintetica dello sviluppo nel tempo di questa evoluzione linguistica,
con riferimento ad alcuni dei linguaggi più noti (in <a class="reference external" href="https://it.wikipedia.org/wiki/Linguaggio_di_programmazione">Linguaggi di programmazione</a> si dice che oggi
si usano più di 2500 linguaggi di programmazione).</p>
<a class="reference internal image-reference" href="_images/historyHLPL.png"><img alt="_images/historyHLPL.png" class="align-center" src="_images/historyHLPL.png" style="width: 60%;" /></a>
<p>L’avvento della programmazione ad oggetti sembra avere segnato il culmine di questo processo;
un motivo può certo essere il raggiungimento di una sufficiente maturità nella capacità espressiva
in ciascuna delle dimensioni citate.</p>
<p>Tuttavia, il motivo principale di una relativa (e solo apparente)
stagnazione nello sviluppo di nuovi linguaggi, può essere ricondotto all’idea che un linguaggio
non deve essere necessariamente accompagnato da una sintassi concreta ma può essere suffciente
definire una <strong>sintassi astratta</strong> utilizzando un <span class="blue">meta-linguaggio</span> come ad esempio <code class="docutils literal notranslate"><span class="pre">MOF</span></code>
(si veda <a class="reference external" href="https://it.wikipedia.org/wiki/Meta-Object_Facility">Meta Object Facility</a>) unitamente alla semantica del linguaggio e a un framework di supporto.</p>
<a class="reference internal image-reference" href="_images/mofUml.PNG"><img alt="_images/mofUml.PNG" class="align-center" src="_images/mofUml.PNG" style="width: 80%;" /></a>
<p>Questa idea è sviluppata oggi con riferimento ai <a class="reference external" href="https://www.jetbrains.com/mps/concepts/domain-specific-languages/">Domain Specific Languages</a>.</p>
<p>Nella <a class="reference internal" href="Introduzione.html#fase2"><span class="std std-ref">FASE2</span></a> utilizzeremo la <a class="reference external" href="https://it.wikipedia.org/wiki/Meta-Object_Facility">Meta Object Facility</a> di UML2 nella versione incorporata in Eclipse
(denominata <a class="reference external" href="https://wiki.eclipse.org/Ecore">Ecore</a>)  per definire un linguaggio che permette di esprimere sistemi software come
oggetti attivi (<strong>attori</strong>) che interagiscono tra loro a scambio di messaggi si comportano come <a class="reference external" href="https://en.wikipedia.org/wiki/Moore_machine">MooreMachines</a>.</p>
</section>
<section id="abstraction-gap-e-topdown">
<span id="abstractiongap"></span><h3>Abstraction GAP e topDown<a class="headerlink" href="#abstraction-gap-e-topdown" title="Permalink to this headline">¶</a></h3>
<p>Va sottolieata, a questo punto, la distanza tra le mosse di base fornite da un automa o da un linguaggio di
programmazione (general-purpose) e quelle necessarie per affrontare
in modo adeguato un problema applicativo, una distanza cui faremo riferimento col termine <span class="blue">abstraction gap</span>.</p>
<a class="reference internal image-reference" href="_images/TopDownBottomUp.PNG"><img alt="_images/TopDownBottomUp.PNG" class="align-center" src="_images/TopDownBottomUp.PNG" style="width: 60%;" /></a>
<p>L’abstraction gap tra un problema dato e le tecnologie esistenti deve essere valutato durante
<a class="reference internal" href="#l-analisi-del-problema">L’analisi del problema</a> .</p>
<p>Se il gap risulta elevato, nasce un valido motivo per impostare il processo di produzione in modo <span class="blue">TopDown</span>
(si veda <a class="reference internal" href="#la-crisi-del-software"><span class="std std-ref">La crisi del software</span></a>), partendo proprio dalla analisi del problema
cercando di trovare le strategie migliori per colmare il gap, anche scegliendo
le tecnologie disponibili più opportune che non sono più un assunto a-priori.</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/topDown.png"><img alt="_images/topDown.png" class="align-center" src="_images/topDown.png" style="width: 40%;" /></a>
</div></blockquote>
<p>Sappiamo però che, in molti casi, si segue un approccio <a class="reference internal" href="#bottomup">bottomUp</a> e quindi porremo molta attenzione nel capire le
strategie migliori per invertire il processo e le motivazioni per fare questa inversione.</p>
</section>
</section>
<section id="indicazioni-sul-processo-di-produzione">
<h2>Indicazioni sul processo di produzione<a class="headerlink" href="#indicazioni-sul-processo-di-produzione" title="Permalink to this headline">¶</a></h2>
<p>Il riferimento ormai universalemente accettato è quello di un processo di sviluppo agile,
che pone al centro il concetto di <span class="blue">modello del dominio</span> applicativo.</p>
<a class="reference internal image-reference" href="_images/agileEMDE.PNG"><img alt="_images/agileEMDE.PNG" class="align-center" src="_images/agileEMDE.PNG" style="width: 70%;" /></a>
<p>Come già osservato i processi  <a class="reference internal" href="#waterfall">waterfall</a> dell’ingegneria tradizionale, lasciano il posto a processi
di tipo iterativo e incrementale.</p>
<a class="reference internal image-reference" href="_images/Spiral.PNG"><img alt="_images/Spiral.PNG" class="align-center" src="_images/Spiral.PNG" style="width: 60%;" /></a>
<p>Supponendo che le nostre attività di laboratorio siano non troppo dissimili a quanto avviene concretamente nel
mondo del lavoro, faremo riferimento a <a class="reference external" href="https://scrumguides.org/">SCRUM</a> che oggi costitusice un diffuso framework per lo sviluppo e il
mantenimento di prodotti complessi (non solo software).</p>
<section id="id1">
<h3>SCRUM<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<a class="reference internal image-reference" href="_images/AgileDevelop.PNG"><img alt="_images/AgileDevelop.PNG" class="align-center" src="_images/AgileDevelop.PNG" style="width: 90%;" /></a>
<p>Un approccio INCREMENTALE (in stile SCRUM, ma non solo) è utile per
aggredire la complessità del problema e per
mettere in luce in primis LE COSE
PIU’ IMPORTANTI e PIU’ CRITICHE senza perdersi in dettagli che possono distogliere
l’attenzione per formare un quadro generale di riferimento.</p>
<p>I vari SPRINT dovrebbero effettuare uno ZOOMING entro MACRO-COMPONENTI
innescando un processo ITERATIVO di analisi, progetto , sviluppo e testing di
quel componente o del SOTTOSISTEMA  che lo SPRINT vuole costruire.</p>
<p>Per questo sarà opportuno impostare ogni SPRINT come un ‘sottoprogetto’
con sua propria spiegazione e testing.
Lo sprint <span class="math notranslate nohighlight">\(n+1\)</span> dovrebbe partire dai
risultati dello sprint <span class="math notranslate nohighlight">\(n\)</span> e preparare un sottosistema (funzionante)
che sarà l’input dello sprint <span class="math notranslate nohighlight">\(n+2\)</span>.</p>
<p>Di particolare rilevanza saranno le fasi di <a class="reference external" href="https://www.agileway.it/sprint-review-meeting/">Sprint review</a> i cui meeting saranno un nuovo modo di concepire le ore di
ricevimento-studenti.</p>
</section>
<section id="il-motto">
<h3>Il motto<a class="headerlink" href="#il-motto" title="Permalink to this headline">¶</a></h3>
<p>Per focalizzare l’attenzione sulla nostra metodologia di costruzione, cercheremo di tenere fede al seguente motto:</p>
<table class="colwidths-given docutils align-default" style="width: 100%">
<colgroup>
<col style="width: 35%" />
<col style="width: 65%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Design first</p></td>
<td><p>TopDown process</p></td>
</tr>
<tr class="row-even"><td><img alt="_images/Motto.png" src="_images/Motto.png" />
</td>
<td><img alt="_images/TopDownHowWhat.png" src="_images/TopDownHowWhat.png" />
</td>
</tr>
</tbody>
</table>
</section>
<section id="il-template">
<h3>Il template<a class="headerlink" href="#il-template" title="Permalink to this headline">¶</a></h3>
<p>Il documento <a class="reference external" href="_static/templateToFill.html">template2022</a> costituisce lo strumento che useremo per rendere esplcite le conoscenze, le decisioni
e i modelli introdotte nelle fasi di analisi e di progetto.</p>
<p>Questo documento intende costituire un punto di riferimento
‘process agnostic’, cioè non ancorato ad alcun specifico processo di sviluppo adottato per costruirlo.</p>
<p>Cercheremo quindi anche di capire il ruolo delle documentazione e le metodologie più adeguate per realizzarla
in modo utile, costruttivo e sistematicamente correlato allo stato corrente del codice.</p>
<p>Anticipiamo qui alcuni aspetti che svilupperemo in modo più approfondito lungo tutto il corso.</p>
<section id="l-analisi-dei-requisiti">
<h4>L’analisi dei requisiti<a class="headerlink" href="#l-analisi-dei-requisiti" title="Permalink to this headline">¶</a></h4>
<p>L’analisi dei requisiti mira a:</p>
<p><span class="remark">definire/chiarire COSA (WHAT) il committente richiede e intende.</span></p>
<p>Occorre fare una analisi del testo che precisi in modo non ambiguo
il significato dei termini usati e le informazioni non esplicitamente espresse.
La costruzione di un <span class="blue">dizionario</span>  in linguaggio naturale è utile ma non risolutiva,
in quanto esprime informazione ancora affetta da ambiguità se non da incoeranza e inconsistenza.</p>
<p>Dunque, le informazioni date in linguaggio naturale servono solo in una fase preliminare
dei lavori.
Occorre esprimere le informazioni in modo ‘formale’, cioè in modo
<strong>comprensible alla macchina</strong>.</p>
<p>A tal fine sono utili i linguaggi che permettono di definire <a class="reference internal" href="#modelli"><span class="std std-ref">Modelli</span></a>
capaci di catturare gli aspetti essenziali, lasciando sullo sfondo dettagli
anche importanti, ma non rilevanti nelle prime fasi.</p>
<p>Gli <a class="reference external" href="https://it.wikipedia.org/wiki/Use_Case_Diagram">Use Cases Diagrams</a> utilizzati in <a class="reference external" href="https://it.wikipedia.org/wiki/Unified_Modeling_Language">UML</a> e le più recenti <a class="reference external" href="https://en.wikipedia.org/wiki/User_story">User Stories</a> possono essere utili
come linea-guida per definire una o più <span class="blue">TestUnits</span> funzionali.
Le specifiche degli <em>Use Cases</em> espresse in linguaggio naturali possono essere inserite
come commenti in tali <em>TestUnits</em>.</p>
<p>Le <span class="blue">domande</span> da porre al committente mirano a <strong>chiarire</strong>:</p>
<ul class="simple">
<li><p>la natura delle entità, cioè se dal punto di vista software,
una entità è (modellabile come un) oggetto (POJO), un servizio, un processo, un attore, etc.</p></li>
<li><p>se le varie entità devono essere distribuite su diversi nodi computazionali</p></li>
<li><p>i vincoli tecnologici, cioè se il committente propone già qualche specifica tecnologia
o qualche specifico supporto per una data entità</p></li>
<li><p>le interazioni (a procedure-call, a messaggi, sincrone, asincrone) tra le diverse entità</p></li>
</ul>
</section>
<section id="l-analisi-del-problema">
<h4>L’analisi del problema<a class="headerlink" href="#l-analisi-del-problema" title="Permalink to this headline">¶</a></h4>
<p>L’analisi del problema mira a:</p>
<p><span class="remark">definire/chiarire le problematiche implicate dai requisiti.</span></p>
<p><span class="remark">fornire informazioni utili sui costi/tempi/risorse necessari.</span></p>
<p>L’analisi del problema <span class="blue">NON IMPLICA ancora alcuna progettazione</span>,
ma mira a fornire un <strong>quadro delle possibili soluzioni tecnologighe</strong>
individuando quelle più utili per il superamento delle problematiche poste dai requisiti.
La scelta finale sarà fatta dal progettista (che potrebbe anche ampliare lo spettro
della indagine - ricordiamo che siamo in un <span class="blue">processo iterativo a spirale</span> ).</p>
<p>L’analisi del problema serve per capire quali sono le maggiori problematiche
da affrontare, le tecnologie da usare e le risorse (umane e temporali) necessarie.
Inoltre gettano le basi per impostare il primo sprint di sviluppo e quindi per
costruire un primo ‘prototipo’ funzionante del sistema da estendere poi in modo
incrementale con gli sprint succesivi dopo una opportuna sprint-review con
il committente</p>
<p>Al termine della analisi dei requisiti e del problema dovrebbe essere definito
un modello del sistema che mette in luce i macro-componenti
e le loro interazioni, cioè una prima <span class="blue">architettura logica</span> del sistema.</p>
</section>
<section id="l-architettura-logica">
<h4>L’architettura logica<a class="headerlink" href="#l-architettura-logica" title="Permalink to this headline">¶</a></h4>
<p>Il risultato della analisi può essere sintetizzato nella definizione di una
<span class="blue">architettura logica</span> che definisce la NATURA (oggetti, processi, servizi, attori, database, etc.)
dei MACRO-COMPONENTI del sistema e della loro interazione,
NON COME SOLUZIONE DI PROGETTO, ma come VINCOLI IMPLICATI dal problema.</p>
<p><span class="remark">Il risultato della analisi del problema dovrebbe essere (del tutto) condiviso</span></p>
<p>Da questa architettura dovrebbe anche scaturire la valutazione dell’<a class="reference internal" href="#abstractiongap"><span class="std std-ref">abstraction gap</span></a> rispetto alle
tecnologie disponibili (librerie, frameworks, piattaforme, etc.)</p>
<p>L’analista potrebbe/dovrebbe dare uno sguardo complessivo al problema,
cercando anche di organizzare tutte le funzionalità per importanza, e come queste
funzionalità debbano essere  distribuite tra i vari MACRO-componenti.</p>
</section>
</section>
<section id="progettazione-e-sviluppo-come-processo-evolutivo">
<h3>Progettazione e sviluppo come processo evolutivo<a class="headerlink" href="#progettazione-e-sviluppo-come-processo-evolutivo" title="Permalink to this headline">¶</a></h3>
<p>L’uso dei modelli è utile (per non dire indispensabile) PER CONCENTRARE
l’attenzione SUGLI ASPETTI RITENUTI SALIENTI (tenendo conto anche
dei tempi, delle tecnologie disponibili  e dei costi).</p>
<p>Come già previsto da <a class="reference external" href="https://it.wikipedia.org/wiki/Unified_Modeling_Language">UML</a>, è opportuno definire modelli come risultato delle
fasi di analisi dei requisiti (<em>Use Case Diagrams</em>), analisi del problema
e del progetto (<em>class diagrams, sequence diagrams</em>, <em>activity diagrams</em>, <em>statechart diagram</em> )
e anche per la distribuzione del prodotto (<em>deployment diagrams</em>).</p>
<p>L’architettura logica espressa mediante un modello esguibile del sistema da realizzare,
condiviso tra tutti (customer, responsabili aziendali, sviluppatori), è un importante e solido punto di partenza
per la progettazione della soluzione, cioè per il passaggio da WHAT a HOW.
Questo passaggio può essere visto e svolto come un <span class="blue">processo evolutivo</span> di trasformazione/specializzazione di questa
architettura di base.</p>
<p>Il modello della architettura logica può essere anche il riferimento per la impostazione di
PIANI di testing espressi in MODO NON discorsivo (formale), comprensibile a una macchina.</p>
<p>Noi seguiremo questa idea con lo sviluppo (si veda <a class="reference internal" href="Introduzione.html#fase2"><span class="std std-ref">FASE2</span></a>) di
un meta-modello custom che permette la definizione di modelli eseguibili di sistemi distributi.</p>
</section>
<section id="il-testing">
<h3>Il testing<a class="headerlink" href="#il-testing" title="Permalink to this headline">¶</a></h3>
<p>L’obiettivo della fase di testing è quello di trovare il maggior numero di situazioni che conducono ad errori
con il minimo numero di casi di prova.
Un  piano di testing  ha di solito lo scopo di stabilire la gerarchia con cui i test vanno eseguiti,
i metodi di esecuzione, i criteri di accettazione e prevede diverse tipologie di test, tra cui:</p>
<ul>
<li><p><strong>Unit test</strong> (Test di unità o di modulo)
Ha l’obiettivo di individuare gli errori nel singolo modulo software.</p></li>
<li><p><strong>Integration Test</strong> (Test di integrazione)
Ha l’obiettivo di individuare gli errori nel software quando tutti i moduli che compongono un sottosistema
o l’intero sistema vengono fatti lavorare assieme.</p></li>
<li><p><strong>System Test</strong> (Test di sistema)
Ha l’obiettivo di garantire che il prodotto software nel suo complesso soddisfi completamente
i requisiti iniziali. E’ un collaudo interno.</p></li>
<li><p><strong>User Acceptance Test</strong> (Test di accettazione)
Ha l’obiettivo di valutare la rispondenza dell’applicazione software rispetto ai requisiti
espressi inizialmente nel contratto e di ottenere l’accettazione formale del cliente di quanto realizzato.
Il test viene effettuato dal cliente nel suo ambiente di test, e da un gruppo di utenti.</p></li>
<li><p><strong>Alpha test e Beta test</strong>
Un <span class="blue">alpha test</span> è un test preliminare di un’applicazione software anche non ancora completa,
eseguito da alcuni potenziali utenti rappresentati da un team.</p>
<p>Un <span class="blue">beta test</span> ha l’obiettivo di far valutare al cliente, prima della distribuzione ufficiale del sistema,
la reale funzionalità, completezza ed operatività dell’applicazione.</p>
</li>
<li><p><strong>Regression Test</strong> (test di non regressione)
Ha l’obiettivo di verificare a valle di una manutenzione, dopo che un bug è stato individuato e corretto
e sono stati eseguiti esattamente gli stessi test che erano stati effettuati quando era stato individuato il problema.</p></li>
<li><p><strong>Stress test</strong> (test di carico)
Ha l’obiettivo di determinare il punto di rottura di un sistema software,
oltre il quale si verificano instabilità del sistema, perdita dei dati o interruzione del servizio.</p></li>
</ul>
<p>Sul problema del testing si trova moltissimo materiale in rete. Riportiamo qui alcuni riferimenti utili sul ‘piano pragmatico’:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Software_testing">Software testing</a> (wikipedia)</p></li>
<li><p><a class="reference external" href="https://softwaretestingfundamentals.com/software-testing-quotes/">Software testing quotes</a></p></li>
<li><p><a class="reference external" href="http://sqa.fyicenter.com/FAQ/Automated-Testing-Plan/">Automated-Testing-Plan FAQ</a></p></li>
<li><p><a class="reference external" href="http://sqa.fyicenter.com/FAQ/JUnit/What_Is_JUnit_.html">JUnit FAQ</a></p></li>
</ul>
</section>
<section id="dal-testing-a-devops">
<h3>Dal testing a DevOps<a class="headerlink" href="#dal-testing-a-devops" title="Permalink to this headline">¶</a></h3>
<p>La fase di testing del software è  attività imprescindibile per garantirne la qualità ed è anche
indispensabile per garantire all’utente una <em>user experience</em> soddisfacente.</p>
<p>In <a class="reference external" href="https://www.ibm.com/it-it/topics/software-testing">Software testing IBM</a>  leggiamo che:</p>
<ul class="simple">
<li><p>Negli anni ‘90 c’è stata una transizione dai test a un processo più completo denominato
<span class="blue">controllo di qualità</span>, che copre l’intero ciclo di sviluppo del software e riguarda
i processi di pianificazione, progettazione, creazione ed esecuzione di casi di test.</p></li>
<li><p>I test del software sono stati tradizionalmente separati dal resto dello sviluppo, ma
molti team di sviluppo  usano ora una metodologia nota come <span class="blue">test continuo</span>.</p></li>
</ul>
<p>Il <em>test continuo</em> è parte dell’approccio <a class="reference external" href="https://it.wikipedia.org/wiki/DevOps">DevOps</a>, in cui sviluppo e operazioni collaborano
per l’intero ciclo di vita del prodotto. L’obiettivo è quello di accelerare la fornitura del software,
bilanciando al tempo stesso i costi, la qualità e i rischi.</p>
<p>Noi porremo particolare attenzione al fatto che la definizione di test (autmatizzabili) può essere vista come
la <strong>formalizzazione</strong> delle <a class="reference external" href="https://en.wikipedia.org/wiki/User_story">User Stories</a>  e che l’uso dei modelli (esguibili) può permettere
di anticipare questa formalizzazione fin dalle fasi di analisi.</p>
<p>Nella fase di analisi, l’obiettivo non è quello di eseguire dei test, ma quello di trovare il modo migliore
per definire i test in modo che possano individuare in modo automatico le falle del software rispetto ai requisiti.</p>
<p>L’obiettivo di definire un TestPlan automatizzabile introduce di fatto un <strong>nuovo requisito</strong>:
<span class="blue">rendere  l’applicazione osservabile</span>, o meglio:</p>
<p><span class="remark">renderne verificabili, da parte di una macchina, gli effetti dell’applicazione</span>.</p>
</section>
<section id="passi-operativi-a-regime">
<h3>Passi operativi ‘a regime’<a class="headerlink" href="#passi-operativi-a-regime" title="Permalink to this headline">¶</a></h3>
<p>Anticipiamo qui le azioni principali che svolgeremo nella <a class="reference internal" href="Introduzione.html#fase3"><span class="std std-ref">FASE3</span></a>, dopo avere sperimentato
nella <a class="reference internal" href="Introduzione.html#fase1"><span class="std std-ref">FASE1</span></a> il modo di procedere oggi più diffuso
ed esserci costruiti un nostro ambiente di sviluppo custom nella <a class="reference internal" href="Introduzione.html#fase2"><span class="std std-ref">FASE2</span></a>:</p>
<ol class="arabic simple">
<li><p>Costruire un repository GIT del progetto.</p></li>
<li><p>Definire un primo modello del sistema come risultato della analisi del problema
(e non del progetto della soluzione).</p></li>
<li><p>Includere nel documento di analisi gli appropriati riferimenti al modello.</p></li>
<li><p>Utilizzare il modello per definire  <strong>Piani di Testing</strong> significativi in relazione alle <a class="reference external" href="https://en.wikipedia.org/wiki/User_story">User Stories</a></p></li>
<li><p>Realizzare il progetto</p></li>
<li><p>Impostare la codifica</p></li>
<li><p>Impostare il deployment e la manutenzione (in prospettiva <a class="reference external" href="https://it.wikipedia.org/wiki/DevOps">DevOps</a>)</p></li>
</ol>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo-unibo.gif" alt="Logo"/>
    
    <h1 class="logo logo-name">iss22</h1>
    
  </a>
</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduzione.html">Introduzione</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Costruire software</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#ingegneria">Ingegneria</a></li>
<li class="toctree-l2"><a class="reference internal" href="#programmatori-non-ingegneri">Programmatori = (non) ingegneri?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sviluppo-bottomup">Sviluppo bottomUp</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#modelli">Modelli</a></li>
<li class="toctree-l2"><a class="reference internal" href="#la-crisi-del-software">La crisi del software</a></li>
<li class="toctree-l2"><a class="reference internal" href="#richiami">Richiami</a></li>
<li class="toctree-l2"><a class="reference internal" href="#il-ruolo-dell-architettura">Il ruolo dell’architettura</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-patterns">Design patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dimensioni">Dimensioni</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#struttura">Struttura</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interazione">Interazione</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#terminologia-di-riferimento">Terminologia di riferimento</a></li>
<li class="toctree-l4"><a class="reference internal" href="#un-problema-applicativo">Un problema ‘applicativo’</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comportamento">Comportamento</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#automi-a-stati-finiti">Automi a stati finiti</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#linguaggi">Linguaggi</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abstraction-gap-e-topdown">Abstraction GAP e topDown</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#indicazioni-sul-processo-di-produzione">Indicazioni sul processo di produzione</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">SCRUM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#il-motto">Il motto</a></li>
<li class="toctree-l3"><a class="reference internal" href="#il-template">Il template</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#l-analisi-dei-requisiti">L’analisi dei requisiti</a></li>
<li class="toctree-l4"><a class="reference internal" href="#l-analisi-del-problema">L’analisi del problema</a></li>
<li class="toctree-l4"><a class="reference internal" href="#l-architettura-logica">L’architettura logica</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#progettazione-e-sviluppo-come-processo-evolutivo">Progettazione e sviluppo come processo evolutivo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#il-testing">Il testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dal-testing-a-devops">Dal testing a DevOps</a></li>
<li class="toctree-l3"><a class="reference internal" href="#passi-operativi-a-regime">Passi operativi ‘a regime’</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="WorkspaceSetup.html">WorkspaceSetup</a></li>
<li class="toctree-l1"><a class="reference internal" href="RadarSystem.html">RadarSystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="RadarSystemAnalisi.html">Analisi del problema</a></li>
<li class="toctree-l1"><a class="reference internal" href="RadarSystemProdottiAnalisi.html">Prodotti della analisi</a></li>
<li class="toctree-l1"><a class="reference internal" href="RadarSystemProgetto.html">Progettazione e sviluppo</a></li>
<li class="toctree-l1"><a class="reference internal" href="RaspberrySoftware.html">RaspberrySoftware</a></li>
<li class="toctree-l1"><a class="reference internal" href="RaspBasicCode.html">RaspBasicCode</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Introduzione.html" title="previous chapter">Introduzione</a></li>
      <li>Next: <a href="WorkspaceSetup.html" title="next chapter">WorkspaceSetup</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Antonio Natali.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/CostruireSoftware.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>