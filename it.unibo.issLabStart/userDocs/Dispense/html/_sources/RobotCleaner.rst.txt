.. role:: red 
.. role:: blue 
.. role:: remark
.. role:: worktodo


.. _visione olistica: https://it.wikipedia.org/wiki/Olismo
.. _Macchina di Moore: https://it.wikipedia.org/wiki/Macchina_di_Moore
.. _CleanArchitecture: https://clevercoder.net/2018/09/08/clean-architecture-summary-review
.. _WebSocket: https://it.wikipedia.org/wiki/WebSocket
.. _jquery: https://www.w3schools.com/jquery/default.asp
.. _coap:  https://en.wikipedia.org/wiki/Constrained_Application_Protocol
.. _mqtt: https://mqtt.org/
.. _californium: https://www.eclipse.org/californium/
.. _paho: https://www.eclipse.org/paho/
.. _Mosquitto: https://mosquitto.org/download/
.. _REST: https://en.wikipedia.org/wiki/Representational_state_transfer


.. _UniboPlanner: ../../../../../it.unibo.planner20/userDocs/LabPlanner.html

==============================
RobotCleaner
==============================



-------------------------------------------
Aprile 2002: requisiti
-------------------------------------------
Muovere il :ref:`VirtualRobot` in modo da coprire tutta la superficie di una stanza vuota.


-------------------------------------------
RobotCleaner: analisi dei requisiti
-------------------------------------------

+++++++++++++++++++++++++++++++
Analisi del testo
+++++++++++++++++++++++++++++++

- Il VirtualRobot (detto brevemente robot) è quello introdotto in :ref:`VirtualRobot`.
- La stanza ha pavimento piano, forma rettangolare ed è delimitata da muri.
- Il robot parte dalla **HOME**, definita come l'angolo formato dai muri denominati ``wallUp`` e  ``wallLeft``.

I requisiti possono essere meglio specificati come segue:
 
+++++++++++++++++++++++++++++++
Requisiti funzionali
+++++++++++++++++++++++++++++++

#. *Copertura*: il robot deve seguire una strategia di movimento che garantisca di 
   esplorare la superficie in modo completo.
#. *VerificaLavoro*: deve essere possibile controllare in modo automatico che la copertura sia stata realizzata.
#. *TipoDelRobot*: il committente ha specificato di essere interessato a un sistema che 
   controlla il :ref:`VirtualRobot`, ma ha anticipato che in futuro vorrà usare un robot reale.
   Al momento però, non siamo obbligati ad affrontare questo requisito.

+++++++++++++++++++++++++++++++
Requisiti non funzionali
+++++++++++++++++++++++++++++++

#. *Proattività*: il robot deve muoversi in modo autonomo fino a compimento del lavoro.
#. *Reattività*: il committente ha prospettato la possibilità che il robot sospenda il lavoro
   in caso di allarmi o altre condizioni (comandi di un operatore, temperatura ambiente elevata, etc.).
   Al momento però, non siamo obbligati ad affrontare requisiti di questo tipo.
#. *Sicurezza*: non vi sono requisiti specifici, se non l'assunzione che vi sia un unico programma di controllo.

-------------------------------------------
RobotCleaner: analisi del problema
-------------------------------------------

Come analisti, poniamo in evidenza i seguenti punti.

+++++++++++++++++++++++++++++++
Il cuore del problema
+++++++++++++++++++++++++++++++

Il problema consiste nel definire un controllore capace di realizzare una strategia di comando sistematica
che permetta di soddisfare i requisiti di *Copertura* e di  *VerificaLavoro*.

+++++++++++++++++++++++++++++++
Strategia di movimento
+++++++++++++++++++++++++++++++

Si possono pensare diverse possibili strategie di movimento sistematico che permettono la verifica.
Ad esempio:

.. list-table:: 
  :widths: 33,33,33
  :width: 100%

  * - .. image::  ./_static/img/VirtualRobot/columnMove.PNG
         :align: center 
         :width: 80%

    - .. image::  ./_static/img/VirtualRobot/spiralmove0.PNG
         :align: center 
         :width: 80%
    
    - .. image::  ./_static/img/VirtualRobot/OndeConcentriche.PNG
         :align: center 
         :width: 80%


 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Movimento per colonne
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nel caso della figura di sinistra, il robot lavora 'per colonne'. In particolare,
procede lungo il muro ``wallLeft``  fino a incontrare ``wallDown``. Qui gira a sinistra,
fa un :blue:`passo laterale` di lunghezza adeguaata, poi gira di nuovo  a sinistra e procede diritto verso il
muro ``wallUp``; quando lo incontra gira a destra fa un :blue:`passo laterale`, rigira verso destra e di nuovo
procede verso ``wallDown``.

*CompletamentoLavoro*:  durante un *passo laterale*, il robot incontrerà di sicuro ``wallRight``: 
come ultima mossa procede lungo 
tale muro fino a che non incontra di nuovo un muro (``wallUp`` o  ``wallDown``) e qui si ferma, 
considerando terminato il lavoro.

*VerificaLavoro*:  consiste nel tenere traccia del numero di passi laterali compiuti lungo il muro 
``wallDown``. Se ogni passo copre una distanza  DR pari alla lunghezza del robot, il numero totale
dei passi da compiere è ``DWallDown/DR + 1``.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Movimento a spirale
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nel caso della figura di centro, il robot procede coprendo aree quadrate di lato ``DR*N``, con ``N=1,2,..,M``.
Questa strategia risulta facile da realizzare per stanza quadrate o quasi, ma è più complicata per 
stanza rettangolari con lati di lunghezza diversa tra loro.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Movimento a onde
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nel caso della figura di destra, il robot segue i bordi della stanza, riducendo via via il lati della stanza di 
DR, lavrando in una 'stanza virtuale' di lati ``DWallDown - N*DR`` e ``DWallLeft - N*DR``, con ``N=1,2,..,M``.

*CompletamentoLavoro*:   quando la stanza virtuale perde una dimensione, il robot deve coprire quallo che rimane.

*VerificaLavoro*: se la parte che rimane ha lato ``L > DR``, può risultare complicato 


:remark:`come analisti, riteniamo adeguata la strategia di lavoro per colonne`

.. memorizzazione del lavoro svolto (del percorso effettuato)

+++++++++++++++++++++++++++++++
Il passo del robot
+++++++++++++++++++++++++++++++

In ogni caso, osserviamo che tutte le strategie di lavoro esaminate si basano su una stessa ipotesi:

:remark:`il robot si muove per passi di lunghezza DR`

La lunghezza **DR** può essere defiita come: 

:remark:`DR=diametro del cerchio di raggio minimo che circoscrive il robot`


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Il robot come unità di misura
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In pratica, il robot (cioè **DR**) diventa la **unità di misura per le distanze**.
La stanza stessa può essere pensata come suddivisa in celle quadrate di lato DR.

.. image::  ./_static/img/VirtualRobot/plant0.PNG
    :align: center 
    :width: 30% 


+++++++++++++++++++++++++++++++++++++++++++
RobotCleaner: Interazioni
+++++++++++++++++++++++++++++++++++++++++++

Il :ref:`VirtualRobot` può ricevere comandi via HTTP o via WS (WebSocket).
Le prospettive delineate dal committente inducono a selezionare l'uso di :ref:`wsConnection`
e quindi di interazioni asincrone.


+++++++++++++++++++++++++++++++++++++++++++
Linguaggio di Comando: da cril a aril
+++++++++++++++++++++++++++++++++++++++++++

Il :ref:`VirtualRobot` comprende messaggi in :ref:`cril<Comandi-base per il robot in cril>`. Altri robot potrebbero 
richiedere comandi identici concettualmente, ma espressi in una sintassi diversa. 
Può essere opportuno introdurre un linguaggio di comando 'technology-independent', che qui 
denominiamo :blue:`aril` (**Abstract Robot Interaction Lanaguage**).




:worktodo:`WORKTODO: formalizzare l'analisi`

 

-------------------------------------------
Maggio 20022: prototipo dopo l'analisi 
------------------------------------------- 

- Occorre definire un **modello** del sistema che descrive in modo 'formale' (comprensibile/eseguibile da una macchina)  
  il risultato che l'analista intende esporre e fornire al progettista come punto di partenza per lo sviluppo.


++++++++++++++++++++++++++++++++++++
RobotCleaner: Architettura
++++++++++++++++++++++++++++++++++++

Il sistema è formato da un componente proattivo che può essere modellato come un attore che opera in un nodo computazionale.

Utlizzando il (meta)modello :ref:`QakActor22<QakActor22>`, la specifica formale può essere:

.. code:: Java

   @Context22(name = "pcCtx", host = "localhost", port = "8083")
   @Actor22(name = MainActorCleaner.myName, contextName = "pcCtx", implement = RobotCleaner.class)
   public class MainActorCleaner {
      ...
   }

Il componente proattivo che definisce la business logic può essere formalizzato come una attore che opera come una 
`Macchina di Moore`_

++++++++++++++++++++++++++++++++++++
RobotCleaner Behaviour
++++++++++++++++++++++++++++++++++++

Progetto: **unibo.wenvUsage22**.


- Gli stati dell'automa che opera secondo un :ref:`Movimento per colonne` sono

   ``activate, start, goingDown, turnGoingDown, goingUp, turnGoingUp, lastColumn, completed, endJob``

.. image::  ./_static/img/Spring/RobotCleanerFsm.PNG
    :align: center 
    :width: 80% 


- L'automa invia (stati ``going..``) al robot comandi di movimento a passi in avanti  come indicato in :ref:`Il passo del robot` e di rotazione, 
  (stati ``turn..``)  definiti nella classe ``VRobotMoves``.

- La *VerificaLavoro* prospettata in :ref:`Movimento per colonne` viene realizzata contando il numero di passi verso ``wallRight`` che deve 
  risultare, nello stato  ``completed`` non inferiore ``DWallDown/DR + 1``. La distanza ``DWallDown`` 
  può essere misurata facendo muovere l'automa
  per passi lunghi DR da ``wallLeft`` a ``wallRight``. Questi compito può essere svolto da una applicazione ad hoc.

   :worktodo:`WORKTODO: Realizzare una applicazione che calcola DWallDown`

- L'automa comunica con il robot (al momento il :ref:`VirtualRobot`) in modo asincrono (attraverso una :ref:`WsConnection`) 
  e riceve dal supporto il messaggio ``endMoveOk`` oppure ``endMoveKo`` al termina di ogni movimento e rotazione.

- Il supporto che trasforma le informazioni di :ref:`WEnv` in messaggi ``endMoveOk`` o ``endMoveKo`` è realizzato a livello applicativo 
  da un POJO, observer di :ref:`WsConnection`, definito dalla classe ``WsConnApplObserver`` che implementa :ref:IObserver`.

   .. code:: Java

      public class WsConnApplObserver extends WsConnSysObserver implements IObserver{
        ...
        @Override
	      public void update(String data) {
         //data : {"endmove":,,,,"move":"..."}
         //data : {"collision":"...","target":"..."}
         //Genera SystemData.endMoveOk o SystemData.endMoveKo
         }
      }
 
- Le transizioni di stato avvegono in conseguenza della ricezione di un messaggio ``endMoveOk`` oppura ``endMoveKo``


Il modello eseguibile è riportato in ``RobotCleanerAnalisi.java``

Progetto: **unibo.wenvUsage22** code: *unibo.wenvUsage22.cleaner.RobotCleanerAnalisi*.

.. code:: Java

   public class RobotCleaner extends QakActor22FsmAnnot{

      @State( name = "activate", initial=true)
      @Transition( state = "start",   msgId= SystemData.startSysCmdId  )
      protected void activate( IApplMessage msg ) { ... }

      @State( name = "start" )
      @Transition( state = "goingDown",   msgId="endMoveOk"  )
      @Transition( state = "endJob",      msgId="endMoveKo"  )
      protected void start( IApplMessage msg ) { ... }
   }



------------------------------------------------------
RobotCleaner: progetto
------------------------------------------------------

Il progettista parte dal modello dell'analisi e inizia con la semplificazione 
dell'automa, riducendo il numero degli stati.

Nello stato  ``coverColumn`` il robot percorre una colonna; la direzione è mantenuta in una variabile
booleana ``goingDown``, che viene usata nello stato ``turn``  per eseguire uno di due macro-mosse:
``turnLeftAndStep`` o ``turnRightAndStep``.

.. image::  ./_static/img/Spring/RobotCleanerFsmProject.PNG
  :align: center 
  :width: 100%


Inoltre il progettista decide di permettere la riattivazione del robot dopo che ha completato il lavoro.
 
 
------------------------------------------------------
RobotCleaner reattivo a comandi
------------------------------------------------------
Al termine della sprint review, il committente, soddisfatto del lavoro, chiede se sia possibile :blue:`realizzare 
una nuove funzionalità`.

**RobotCleaner reattivo**: Estendere il funzionamento di il :ref:`RobotClenaer<RobotCleaner Behaviour>` 
in modo da eseguire i seguenti comandi inviati da un controllore (umano o macchina):

- ``start`` (id = ``SystemData.startSysCmdId``) attiva il robot, che parte dalla posizione HOME
- ``stop`` (id = ``SystemData.stopSysCmdId``): ferma il robot nella posizione corrente
- ``resume`` (id = ``SystemData.resumeSysCmdId``): riattiva il robot dalla posizione corrente


A questo punto si potrebbe pensare alla seguente pianificazione del lavoro:

#. Si estende il behavior introdotto in :ref:`RobotCleaner Behaviour`, tenendo conto dei nuovi possibili messaggi.
#. Si realizza una Web User Interface utlizzando SpringBoot. Per questa parte si veda 
   :ref:`Una WebConsole per il RobotCleaner`

++++++++++++++++++++++++++++++++++++++++++++++++
Troppo precipitosi?
++++++++++++++++++++++++++++++++++++++++++++++++

Partire con l'idea di procedere lavorando immediatamente su una **estensione  del funzionamento** significa 
a :blue:`non trattare in modo esplcito` due punti importanti:

#. come si modifica l'architettura logica del sistema
#. quale è il significato di :blue:`fermare e riattivare`: dopo uno ``stop``, il robot potrebbe dover eseguire altre azioni? 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
La nuova architettura logica
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:worktodo:`WORKTODO: impostare un modello (eseguibile) della nuova architettura`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Il significato di stop/resume
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
Il committente chiarisce che il robot, sopo un comando di ``stop``, **al momento**,
non deve eseguire alcuna altra azione, se non rimanere in attesa di un ``resume``.


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Il nuovo piano di lavoro
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

#. Si realizza un attore che simula l'operatore umano che invia i comandi
#. Si verifica il funzionamento del nuovo prototipo
#. Al termine, si realizza una WebApplication con SpringBoot.


Partendo dal modello della analisi, si considera 
la possibilità di gestire un messaggio di ``stop`` negli stati marcati nella figura che segue.

.. image::  ./_static/img/Spring/RobotCleanerFsmStartStopAnalisi.PNG
  :align: center 
  :width: 80%

Per una versione di questo tipo si veda

   Progetto: **unibo.wenvUsage22** code: *unibo.wenvUsage22.cleaner.RobotCleanerStartStop*.

Per ogni stato ``XXX`` marcato, nasce uno stato ``stoppedXXX`` in cui l'automa transita alla ricezione di un
comando di ``stop``. Questo stato rimane in attesa di un comando di ``resume``, alla ricezione del
quale transita nello stato ``resumedXXX``, che provvede ad elaborare il messaggio  ``endMoveOk``
o  ``endMoveKo`` che avrebbe dovuto provocare una transizione dello stato ``XXX``.


Ad esempio:

.. image::  ./_static/img/Spring/RobotCleanerFsmStartStopAnalisiNoInterrupt.PNG
  :align: center 
  :width: 80%

.. Progetto: **unibo.wenvUsage22** code: *unibo.wenvUsage22.cleaner.RobotCleanerStartStop*.

.. code:: Java

   @State( name = "stoppedDown" )
   @Transition( state = "resumedDown",  msgId= SystemData.resumeSysCmdId  )
   protected void stoppedDown( IApplMessage msg ) {
      outInfo("" + msg);
   }

   @State( name = "resumedDown" )
   @Transition( state = "goingDown",     msgId="endMoveOk"  )
   @Transition( state = "turnGoingDown", msgId="endMoveKo"  )
   protected void resumedDown( IApplMessage msg ) {
      outInfo("" + msg);
   }


Il progettista potrebbe applicare lo stesso modo di procedere al modello :ref:`RobotCleaner: progetto`.

Tuttavia, il progettista si chiede se non sia opportuno un approfondimento dell'analisi del problema,
innescando una retroazione verso l'analista (tipico di un 
:ref:`processo incrementale, a spirale<L'analisi del problema>`).

++++++++++++++++++++++++++++++++++++++++++++++++
Stop/resume: un nuovo abstraction gap? 
++++++++++++++++++++++++++++++++++++++++++++++++

La semantica stop/resume delineata in precedenza ricorda il meccanismo delle interruzioni (:blue:`interrupt`) 
che implica:

#. una memorizzazione (nello stack) del stato della CPU
#. il trasferimento del controllo alla interrupt-routine e 
#. il ripristino dello stato salvato al termine di questa, con il ritorno al processo computazionale interrotto.

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Stop/resume come interrupt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Tranedo ispirazione dal meccanismo degli :blue:`interrupt`, il team di sviluppo ha concordato sulla opportunità
di rendere disponibile un meccanismo analogo da parte della infrastruttura di supporto agli attori, che è stata
così modificata:

- viene  introdotto un attributo **interrupt** alle transizioni (una sola per stato)
- quando uno stato S ha una transizione con ``interrupt=true``, lo si  memorizza prima di passare al prossimo stato. 
  Si memorizza anche a una copia della tabella delle transizioni che l'automa avrebbe potuto
  effettuare in assenza dell'interrupt
- se il prossimo stato (``S_I``) è quello relativo alla transizione qualificata come interrupt, 
  lo si esegue normalmente, ma alla fine della esecuzione di ``S_I``, come ultima operazione si deve eseguire 
  l'operazione built-in :blue:`resume` 
  (una sorta return form interrupt) che ripristina la tabella delle transizioni memorizzata. In tal modo 
  ``S_I`` opera come avrebbe fatto ``S`` se non ci fosse stato l'interrupt, attigendo dai messaggi non gestiti
  memoriizzati (``OldMsgQueue``)


Osserviamo che dallo stato ``S_I`` si potrebbero avere anche transizioni normali verso altri stati. 
Basta che la nuova catena computazionale termini con una :blue:`resume`.

Con questo meccansimo, il nuovo diagramma di progetto si presenta come segue:

.. image::  ./_static/img/Spring/RobotCleanerFsmStartStopProject.PNG
  :align: center 
  :width: 100%

La sua formalizzazione in codice si presenta in qyesto modo:

 Progetto: **unibo.wenvUsage22** code: *unibo.wenvUsage22.cleaner.RobotCleanerProject*.

.. code:: Java
   
   public class RobotCleanerInterrupt extends QakActor22FsmAnnot{
    ...
      @State( name = "goingDown" )
      @Transition(state="stopped",
           msgId=SystemData.stopSysCmdId,interrupt=true)
      @Transition( state = "goingDown",     msgId="endMoveOk"  )
      @Transition( state = "turnGoingDown", msgId="endMoveKo"  )
      protected void goingDown( IApplMessage msg ) {
         outInfo(""+msg);
         VRobotMoves.step(getName(), conn );
      }
      ...
      @State( name = "stopped" )
      @Transition(state="backToInterrupted",msgId=SystemData.resumeSysCmdId)
      protected void stopped( IApplMessage msg ) {
         outInfo("" + msg);
      }

      @State( name = "backToInterrupted" )
      protected void backToInterrupted( IApplMessage msg ) {
         outInfo("" + msg);
         resume();
      }
   }



-----------------------------------------------
Una WebConsole per il RobotCleaner
-----------------------------------------------

Ci poniniamo l'obiettivo di creare una :ref:`WebApplication con SpringBoot` che mostri agli utenti una pagina  HTML come quella di figura:

.. image::  ./_static/img/Spring/RobotCleanerGui.PNG
  :align: center 
  :width: 80%


:remark:`La business logic è nel prototipo RobotCleaner`

- Obiettivo della applicazione Spring è solo quello di offrire una GUI. Tutta la logica applicativa è già stata realizzata 
  (e testata) e può essere resa disponibile mediante un file ``jar``.


.. _modiCreazione:

:remark:`Chi crea il componente applicativo?`

Vi sono due modi principali:

#. *Modo remoto*: Il componente applicativo viene allocato su un nodo diverso da quello che ospita l'applicazione Spring
#. *Modo locale*: Il componente applicativo viene creato dalla applicazione Spring stessa


:worktodo:`WORKTODO: discutere i pro/contro dei due modi`

In questa sezione continueremo ad usare il progetto denominato **webForActors** introdotto in :ref:`Primi passi con SpringBoot`.

+++++++++++++++++++++++++++++++++++++++++++++
RobotCleanerGui.html
+++++++++++++++++++++++++++++++++++++++++++++

- Inseriamo il file ``RobotCleanerGui.html`` nella directory **templates**.

Qyesto file definisce la struttura della pagina HTML, suddivisa in due zone:

- area **Condigurazione e comandi**: questa zona realizza un dispositivo  di input, con cui l'utente può inviare comandi al server

  .. code::

   <h4>Commands to the RobotCleaner</h4>
    ...
     <table>
      <table style="width:50%">
      <tbody>
      <!-- the form-data is sent to the page specified in the action attribute -->
      <tr>
      <td > <form action="robotcmd" method="post"><button name="cmd" value="t">start</button></form></td>
      <td> <form action="robotcmd" method="post"><button name="cmd" value="stop">stop</button></form></td>
      <td> <form action="robotcmd" method="post"><button name="cmd" value="resume">resume</button></form></td>
      </tr>
      </table>
      </center>
   </td>

 - **Display Area**: questa zona realizza un dispositivo di output, in cui visualizzare informazioni di stato (mediante
   una :ref:`WebSocket<WebSocket in SpringBoot: versione base>`).

   .. code::

     <h3>DISPLAY AREA</h3>
     <div id = "display"></div>

   L'aggiornamento della DisplayArea verrà realizzato da codice JavScript (si veda più avanti: :ref:`wsminimal.js`).

+++++++++++++++++++++++++++++++++++++++++++++
Un controller per la RobotCleaner Appl 
+++++++++++++++++++++++++++++++++++++++++++++

Commentiamo l'annotazione ``@Controller`` in ``HIControllerDemo`` e inseriamo un nuovo controller ``HIController`` 

.. _HIController:

.. code:: Java

    package it.unibo.webspring.demo;
    import ...
    
    @Controller 
    public class HIController { 
    private static final String robotCmdId = "move";
    private static  String robotName       = "cleaner";
    
    private String mainPage = "RobotCleanerGui";

    public HIController(){   }


Il  controller ``HIController``  gestisce:

- le richieste (HTTP-GET) di apertura della pagina:
  
   .. code:: Java

      @GetMapping("/") 		 
      public String homePage(Model model) {
         model.addAttribute("arg", appName);
         return mainPage;
      } 

- le informazioni di configurazione inviate con metodi HTTP-POST, quando l'utente (umano) preme il pulsante **Configure**

   .. code:: Java

      //Dopo click sul pulsante Configure
      @PostMapping("/configure")
      public String configure(Model viewmodel, 
               @RequestParam String move, String addr ){
         createRobotCleaner();  //Modo locale per la Business logic:
         ConnQakBase connToRobot = 
               ConnQakBase.create( ProtocolType.tcp );
         conn = connToRobot.createConnection(addr, 8083);
         return mainPage;
      }

   La classe ``ConnQakBase`` è una utility per creare connessioni al Robot con un dato protocollo.

   .. image::  ./_static/img/Spring/RobotCleanerFsmStartStopProject.PNG
      :align: center 
      :width: 80%   

- i comandi inviati con metodi HTTP-POST, quando l'utente (umano) preme i pulsanti **start / stop / resume**

   .. code:: Java
 
      //Dopo click sul pulsante start/stop/resume
      @PostMapping("/robotcmd")
      public String doMove(Model viewmodel, @RequestParam String cmd){
         if( cmd.equals("t")){  //Start
               Qak22Util.sendAMsg( SystemData.startSysCmd("hicontroller",robotName) );
         }else{
               try {
                  String msg = moveAril(cmd).toString();
                  conn.forward( msg );
               } catch (Exception e) {... }
         }
         return mainPage;
      }

   Notiamo che:

   - il pulsante  **start**   invia un comando (``cmd``)  con valore  **t**,  a fronte della form HTML

     .. code::
    
        <form action="robotcmd" method="post">
            <button name="cmd" value="t">start</button>
        </form>

   - i pulsanti  **stop/resume**   inviano un comando (``move``)  con valore uguale al nome del pulsante:

     .. code::
      
      <form action="robotcmd" method="post">
            <button name="cmd" value="stop">stop</button>
      </form>
 

-------------------------------------------
RobotCleaner:  display area
-------------------------------------------    

Affrontiamo ora un nuovo requisito:

- **DisplayaAreaUpdate**: Il ``RobotCleaner`` deve fornire informazioni di stato che la pagina Web deve visualizzare nella DisplayArea.

+++++++++++++++++++++++++++++++++++++++++
DisplayArea: analisi del problema
+++++++++++++++++++++++++++++++++++++++++

La nostra analsisi parte tenendo conto dei seguenti vincoli (**requisiti non funzionali**):

#. Per i principi delle  `CleanArchitecture`_, il ``RobotCleaner`` non deve avere conoscenza di questo nuovo requisito e non deve avere alcuna 
   dipendenza verso la parte Web.
#. L'aggiornamernto della pagina Web dovrebbe avvenire in modo asincrono, senza ricorso al polling. 


Questi due vincoli, presi insieme, implicano che:

- il ``RobotCleaner`` non deve rispondere a richieste volte a conoscere  il proprio stato. Piuttosto deve essere un ente **osservabile**, cioè
  capace di emettere informazioni utili per componenti software interessati, anche **'alieni'**, cioè non-attori;
- il WebServer, responsabile dell'aggiornamento della pagina Web, dovrebbe operare come un 'alieno', osservatore del  ``RobotCleaner``;
- in quanto osservatore interessato alle informazioni emesse dal ``RobotCleaner``, il WebServer non deve essere vincolato a risiedere 
  sullo stesso nodo di elaborazione  del ``RobotCleaner``
- la pagina Web deve essere aggiornata usando le `WebSocket`_

+++++++++++++++++++++++++++++++++++++++++
DisplayArea: architettura
+++++++++++++++++++++++++++++++++++++++++

L'architettura logica di riferimento può essere rappresentata come nella figura che segue:


.. image::  ./_static/img/Spring/RobotCleanerGuiArch.PNG
   :align: center 
   :width: 60%   


Il componente :ref:`WebSocketHandler<Il gestore WebSocketHandler>` nasce da quanto esposto in 
:ref:`Configurazione con WebSocketConfigurer` (si veda :ref:`Configurazione lato Server` ).


+++++++++++++++++++++++++++++++++++++++++
DisplayArea: piano di lavoro
+++++++++++++++++++++++++++++++++++++++++

Al termine della analisi, riteniamo opportuno proporre il seguente piano di lavoro:

#. ``SPRINT1(ws)``: impostare il WebServer in modo da utilizzare connessioni mediante WebSocket con i client collegati, mediante 
   il framework SpringBoot (a tal fine si veda :ref:`WebSockets in SpringBoot<WebSocket in SpringBoot: versione base>`). 
#. ``SPRINT2(udapte)``: realizzare il ``RobotCleaner`` come emettitore di eventi percepibli dal WebServer.


Gli obiettivi (*Goals*) di ciascun SPRINT, possono essere definiti come segue: 

- nello ``SPRINT1(ws)``: realizzare il file ``wsminimal.js``, il componente ``WebSocketHandler`` e verificare che il
  WebServer sia in grado di inviare informazioni sulla DisplayArea;
- nello ``SPRINT2(update)``: realizzare un meccanismo/supporto che permetta all'attore ``RobotCleaner`` di emettere 
  informazioni che possano essere ricevute dal WebServer (in particolare dal ``WebSocketHandler``) in modo 
  che possano essere visualizzate nella DisplayArea. Nella figura della architettura, questo meccanismo è 
  relativo alla freccia tratteggiata.

La :blue:`valutazione di complessità` ci porta a indicare lo  ``SPRINT2(update)`` come più rischioso e difficile, in quanto
richiede progettazione ad hoc, mentre lo ``SPRINT1(ws)`` richiede 'solo' lo studio delle 
:ref:`WebSockets in SpringBoot<WebSocket in SpringBoot: versione base>`.


+++++++++++++++++++++++++++++++++++++++++
SPRINT1(ws)
+++++++++++++++++++++++++++++++++++++++++

Per gestire le due aree (di input/output) introdotte in :ref:`RobotCleanerGui.html`, la pagina si avvale di `jquery`_ 
e del codice JavaScript defnito nel file *wsminimal.js* 
con cui la pagina si connette a una WebSocket su ``localhost:8085`` e riceve dati (metodo  ``onmessage``)  
che visualizza nella *Display Area*. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
wsminimal.js
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

.. code::   

   const messageWindow   = document.getElementById("display");

   function sendMessage(message) {
      var jsonMsg = JSON.stringify( {'name': message});
      socket.send(jsonMsg);
      addMessageToWindow("Sent Message: " + jsonMsg);
    }

   function addMessageToWindow(message) {
      //messageWindow.innerHTML += `<div>${message}</div>` //add
      messageWindow.innerHTML = `<div>${message}</div>`  //set
   }

   function connect(){
      var host       =  "localhost:8085"; //document.location.host;
      var pathname =  "/"//document.location.pathname;
      var addr     = "ws://" +host  + pathname + "socket"  ;
      // Assicura che sia aperta un unica connessione
      if(socket !== undefined && socket.readyState !== WebSocket.CLOSED){
         alert("WARNING: Connessione WebSocket già stabilita");
      }
      var socket = new WebSocket(addr);
      socket.onopen = function (event) {
         addMessageToWindow("Connected to " + addr);
      };

      socket.onmessage = function (event) {
         addMessageToWindow(""+`${event.data}`);
      };
      return socket;
   }//connect

   connect()

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Configurazione lato Server
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Sul lato del WebServer, SpringBoot impone una :ref:`Configurazione con WebSocketConfigurer` che richiede la implementazione
dell'interfaccia ``WebSocketConfigurer`` e la registrazione di un gestore che estende la casse ``AbstractWebSocketHandler``.

La nostra versione della classe ``WebSocketConfiguration`` che implementa ``WebSocketConfigurer``,
offre un metodo static che restituisce il gestore registrato e il wspath:

.. code:: java

    public static final WebSocketHandler wshandler = new WebSocketHandler();
    public static final String wspath              = "socket";

In base a questa configurazione, il server risponderà a richieste inviate sulla WebSocket al seguente indirizzo:

.. code:: java

    ws://<serverIP>:8085/socket

+++++++++++++++++++++++++++++++++++++
IWsHandler e WebSocketHandler
+++++++++++++++++++++++++++++++++++++

Il nostro gestore è simile  a quanto introdotto :ref:`Il gestore WebSocketHandler`; in più implementa la interfaccia:

.. code:: java

   public interface IWsHandler {
      void sendToAll(String message);
   }

Il metodo ``sendToAll`` permette di inviare informazioni a tutti i client collegati attraverso la WebSocket.

.. code:: java

   public class WebSocketHandler extends AbstractWebSocketHandler implements IWsHandler {
   private final List<WebSocketSession> sessions = new CopyOnWriteArrayList<>();
    ...
      @Override
      protected void handleTextMessage(WebSocketSession session, TextMessage message) throws IOException {
         sendToAll("echo:"+message.toString());
      }

    public void sendToAll(TextMessage message) throws IOException{
        Iterator<WebSocketSession> iter = sessions.iterator();
        while( iter.hasNext() ){
            iter.next().sendMessage(message);
        }
    }

Per propagare un messaggio a tutti i client connessi attraverso la WebSocket,  :ref:`Il gestore WebSocketHandler` tiene traccia
delle sessioni in una struttura dati (*sessions*).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
DisplayArea testing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Una prima verifica della soluzione proposta si articola su diverse situazioni:

- in **locale** (entro la pagina): si visualizza un messaggio di avvenuta connessione col server tramite la WebSocket;
- in **remoto** (informazioni da WebServer): si invia un messaggio di avvenuta configurazione 
  da parte di :ref:`Configurazione con WebSocketConfigurer`;

  .. code:: java

     @Configuration
     @EnableWebSocket
     public class WebSocketConfiguration implements WebSocketConfigurer {

     public static final WebSocketHandler wshandler=new WebSocketHandler();
     public static final String wspath             = "socket";

     public WebSocketConfiguration(){
      new Thread(){ //To test ws-connection
         public void run(){
            wshandler.sendToAll("WebSocketConfiguration created" );
         }
      }.start();
     }
     ...
     }

- da **programma** (connessioni su Ws): si crea un programma Java che utilizza :ref:`WsConnection` 
  (la implementazione osservabile di  :ref:`Interaction2021` sulle ws) per inviare comandi al WebServer. 
  
  In modo simile al ``ClientUsingWs`` introdotto in  :ref:`Esempi di uso di HttpConnection e WsConnection`,  
  definiamo un client che invia al WebServer la stringa "Hello from remote client". 
  Vedremo ricomparire la stringa come echo nella DisplayArea.

  Progetto: **webForActors** code: *unibo.webForActors.ClientUsingWs*. 
 

+++++++++++++++++++++++++++++++++++++++++
SPRINT2(update)
+++++++++++++++++++++++++++++++++++++++++

Dal punto di vista logico, il ``RobotCleaner`` è stato modellato come un emettitore di :ref:`Eventi`, 
ma il sistema si presenta come 
**eterogeneo**: infatti non tutti i componenti del sistema seguono il modello ad :ref:`Attori`. In particolare:

:remark:`il WebServer è progettato e costruito 'al di fuori' del modello ad  Attori`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Una soluzione sbagliata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nel caso in cui il ``RobotCleaner`` sia attivato in *Modo locale* (si veda `modiCreazione`_), una soluzione 
possibile sarebbe introdurre codice supplementare nell'attore. Ad esempio:


.. code:: Java

  public class RobotCleanerProject extends QakActor22FsmAnnot{
   ...
   @State( name = "coverColumn" )
   protected void coverColumn( IApplMessage msg ) {
      ...
      WebSocketConfiguration.wshandler.sendToAll(""+msg);
   }
  }

:remark:`Questa soluzione funziona ma è errata`

Infatti crea una dipendenza dell'attore dalla tecnolgia usata per l'aggiornamento delle pagine Web.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Emettere e percepire informazione (eventi)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Per evitare che ``RobotCleaner`` subisca modifiche indebite, potremmo affrontare il problema
dell'osservabilità in tre modi:

#. Rendere *'componenti alieni'* capaci di percepire eventi emessi da attori :ref:`ActorQak e QakActor22`.
#. Realizzare l'emissione di un evento da parte dell'attore ``RobotCleaner`` utilizzando un :blue:`protocollo  publish-subscribe`  come MQTT. 
   Il WebServer potrebbe iscriversi (**subscribe**) alla topic su cui l'attiore pubblica le informazioni. 
#. Rendere l'attore ``RobotCleaner`` una :blue:`risorsa CoAP osservabile`. Il WebServer potrebbe utlizzare 
   un :blue:`CoAP client` per ricevere le informazioni di stato quando sono emeesse.

La infrastruttura degli attori ``QakActor22`` è definita in modo da rendere possibili enatrambe le ultime due strade.
La infrastruttura degli attori ``ActorQak`` rende possibile anche la prima.

In questa sede, ci concentriamo sulla strada meno convenzionale, che 
considera le interazioni  tra componenti distribuiti come uno scambio di **rappresentazioni di risorse** 
accessibili in stile `REST`_. 

Il compito è agevolato dal fatto che ogni attore :ref:`ActorQak e QakActor22` è stato definito in modo da essere 
anche una :blue:`risorsa CoAP osservabile` come descritto in :ref:`Attori come risorse CoAP`.

+++++++++++++++++++++++++++++++++++++++++
RobotCleaner come risorsa CoAP
+++++++++++++++++++++++++++++++++++++++++

L'attore che realizza il ``RobotCleaner`` costituisce una :ref:`risorsa CoAP-osservabile<Attori come risorse CoAP>` , che viene 
aggiornata usando il metodo  ``updateResourceRep``. La dipendenza indebita si prima viene così superata come segue:

.. code:: Java

  public class RobotCleanerProject extends QakActor22FsmAnnot{
   ...
   @State( name = "coverColumn" )
   protected void coverColumn( IApplMessage msg ) {
      ...
      //WebSocketConfiguration.wshandler.sendToAll(""+msg);
      updateResourceRep(""+msg);
   }
  }

L'invocazione di ``updateResourceRep(M)`` provoca l'invio della stringa M a tutti i CoAP client connessi 
alla risorsa.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Il configuratore MainRobotCleaner
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

La fase di configurazione sul WebServer che permette l'uso (in *modo locale* o in *modo remoto*) 
del ``RobotCleaner`` deve ora  creare un :ref:`RobotCleanerObserver` 
che riceve un riferimento
al :ref:`WebSocketHandler<IWsHandler e WebSocketHandler>` memorizzato in ``WebSocketConfiguration.wshandler``.

Introdurremo la  creazione del :ref:`RobotCleanerObserver` nel metodo di configurazione di `HIController`_:

.. code:: Java
      
   //Dopo click sul pulsante Configure
   @PostMapping("/configure")
      public String configure(Model viewmodel, 
               @RequestParam String move, String addr ){
         createRobotCleaner();  //Modo locale per la Business logic:
         ConnQakBase connToRobot = 
               ConnQakBase.create( ProtocolType.tcp );
         conn = connToRobot.createConnection(addr, 8083);

         RobotCleanaerObserver obs = new RobotCleanaerObserver("8083",robotName);
         obs.setWebSocketHandler(WebSocketConfiguration.wshandler);         
         
         return mainPage;
      }
 

- :remark:`Il RobotCleaner non dipende in alcun modo dalla WebApplication`

Inoltre:

- :remark:`E' il RobotCleaner che decide quali informazioni rendere visibili`

+++++++++++++++++++++++++++++++++++++++
RobotCleanerObserver
+++++++++++++++++++++++++++++++++++++++

Il compito dell'osservatore del  ``RobotCleaner`` è di creare un CoAP-client capace di ricevere le informazioni sui cambiamenti di stato
'emesse' dal ``RobotCleaner``
(in quanto  CoAP-resource) e invocare il metodo ``sendToAll`` del :ref:`WebSocketHandler<IWsHandler e WebSocketHandler>` che 
aggiorna la DisplayArea di tutti i client collegati.


.. code:: Java

   public class RobotCleanaerObserver {
   private CoapObserveRelation relation = null;
   private CoapClient client = null;
   private IWsHandler wsh ;

   public RobotCleanaerObserver(String port, String actorName){
    client=new CoapClient("coap://localhost:"+port+"/actors/"+actorName);
    observe();
   }

   public void setWebSocketHandler(IWsHandler h){
      wsh = h;
   }
   public void  observe( ) {
      relation = client.observe(
         new CoapHandler() {
            @Override public void onLoad(CoapResponse response) {
            String content = response.getResponseText();
            if( wsh != null ) wsh.sendToAll(content);
         }					
         @Override public void onError() {
            ColorsOut.outerr("OBSERVING FAILED (press enter to exit)");
         }
      });		
   }


  
++++++++++++++++++++++++++++++++++++++++++
Permanenza delle info nella DisplayArea
++++++++++++++++++++++++++++++++++++++++++

Purtroppo le informazioni inviate sulla WS **non permangono visibili** in quanto la pagina viene aggiornata dopo ogni comando.
Per superare questo problema, possiamo inviare i comandi sulla WS stessa, invece che con HTTP-POST, realizzando di fatto una 
forma di Machine-to-machine (M2M) interaction.

Si provi ad esempio ad inserire nella pagina `RobotCleanerGui.html`_ una nuova area-comandi:

.. code::

   <h4>COMMAND-WS AREA</h4>

   <button id="startws" >startWs</button>  
   <button id="stopws" >stopWs</button>
   <button id="resumews" >resumeWs</button>

 
.. image::  ./_static/img/Spring/RobotCleanerGuiPlus.PNG
   :align: center 
   :width: 40%   


Il file `wsminimal.js`_  vine arricchito con codice `jQuery`_ che invia comandi sulla WebSocket:


.. code::

   $(function () { //short-hand for $(document).ready(function() {...});
      $( "#startws" ).click(function() { socket.send("start");    })
      $( "#stopws" ).click(function() { socket.send("stop");  })
      $( "#resumews" ).click(function() { socket.send("resume");  })
   });

Premendo sui nuovi pulsanti, si vedranno comparire (come echo) i comandi,
ritrasmessi ai client dal metodo ``handleTextMessage`` di :ref:`WebSocketHandler<IWsHandler e WebSocketHandler>`.

:worktodo:`WORKTODO: realizzare i comandiWs`

- estendere il codice di ``handleTextMessage`` di :ref:`WebSocketHandler<IWsHandler e WebSocketHandler>` in modo da inviare 
  gli opportuni messaggi  al ``RobotCleaner``.

++++++++++++++++++++++++++++++++++++++++++
Nuove opportunità
++++++++++++++++++++++++++++++++++++++++++

Notiamo che, lanciando il programma ``unibo.webForActors.ClientUsingWs``, questo visualizzerà tutte le informazioni emesse da 
``RobotCleaner``.
Cio ci induce ad asserire che:

- :remark:`Abbiamo un meccanismo utile per il testing automatizzato` 

:worktodo:`WORKTODO: aggiornare un log file delle variazioni di stato del RobotCleaner`

- Scrivere un programma Java (etserno alla WebApplication) che crea un Observer della CoAP-resource ``RobotCleaner`` che aggiorna 
  un file di log di tutte  le informazioni emesse dal robot.

 
-------------------------------------
RobotCleaner: back to HOME
-------------------------------------

Un ``RobotCleaner`` potrebbe dover essere reattivo a comadi o situazioni che non richiedono solo una
momentanea interruzione delle attivtà che sta eseguendo come sua parte proattiva, ma anche
un radicale cambiamento di queste.

Ad esempio, il robot potrebbere ricevere un comando di ``BacktoToHome``.

.. :worktodo:`WORKTODO: comando returnToHome`

.. analizzare le problematiche connesse al comando ``returnToHome`` e proporre un modello di soluzione

++++++++++++++++++++++++++++++++++++++++++++++++++++++
BackToHome: analisi del requisito e del problema
++++++++++++++++++++++++++++++++++++++++++++++++++++++

Un comando di ritorno in HOME senza ulteriori indicazioni, potrebbe essere eseguito in modo semplice,
avvaledosi del fatto che il robot potrebbe proseguire lungo la direzione corrente fino a incontrare:

- *wallUp* : in questo caso il robot si gira sinistra e percorre il borso superiore
- *wallDown* :  in questo caso il robot si gira a destra e percorre prima il borso inferiore e poi il bordo sinistro.

In altre parole esiste una strategia di soluzione che **non richiede conoscenza** della
posizione corrente del robot e/o il percorso svolto fino a quel punto.

In geenerale però, la :blue:`conoscenza del persorso e della posizione` potrebbe essere importante e necessaria.
Si pensi ad esempio al caso in cui il committente precisi il requisito nel modo che segue:

- **BackToHomeFast**: al comando ``returnToHome``, il robot deve tornare in HOME seguendo il percorso più breve (o, in alternativa,
  con il numero minimo di spostamenti)

Oppure
 
- **BackToHomeClean**: al comando ``returnToHome``, il robot deve tornare in HOME limitando al minimo di ripercorrere il percorso già fatto
  (il pavimento pulito) o limtando.

In generale poi, le applicazioni che richiedono il controllo di un robot mobile (tra cui il ``RobotCleaner``) raramente 
si svolgono in una stanza vuota; di solito sono presenti vari ostacoli fissi all'interno della stanza.
In questo caso, ammesso che tali ostacoli siano stati opportunamente evitati durante la fase di pulizia, 
la strategia di ritono potrebbe complicarsi.


-------------------------------------
RobotMapperBoundary
-------------------------------------
Progetto: **webForActors** code: unibo.Robots.mapper.RobotMapperBoundary*.  

Un robot che percorre i bordi della stanza (come il :ref:`BoundaryWalker<BoundaryWalkerAnnot`) e che 

- utilizza le features  del pianificatore `UniboPlanner`_ per creare una mappa della stanza come matrice di celle quadrate di lunghezza 
  pari a una :ref:`unità robitica<Il robot come unità di misura>`.
- ha un  comportamento definito come un :ref:`FSM<Un primo automa a stati finiti>` che utilizza le guardie 'versione Lenzi'
- rende visibile una rappresentazione corrente della mappa  ad ogni cambio di direzione 

Per questa applicazione, il WebServer offre la pagina definita in ``RobotNaiveGui.html``.


 




 

