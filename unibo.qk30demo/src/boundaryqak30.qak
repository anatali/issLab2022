/*
 * Muove il virtualrobot lungo il perimetro
 * eseguendo comandi init/stop/resume di una console
 * 
 * Usando basicrobot22.yaml, la scena può essere modificata con comandi del tipo: 
 * docker cp sceneConfig.js 87c9eb2e0989:/home/node/WEnv/WebGLScene/sceneConfig.js
 */
System boundaryqak30 //-msglog    
 
//Related to the console
Dispatch init      : init(X)
Dispatch resume    : resume(X)
Dispatch stop      : stop(X)

//Related to the basicrobot
Dispatch cmd       : cmd(MOVE)     
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)

//Related to the observer, generated by the runtime
Dispatch coapUpdate: coapUpdate(RESOURCE, VALUE)

Event alarm        : alarm(X)

Context ctxboundaryqak30   ip [host="localhost" port=8032]
Context ctxbasicrobot      ip [host="127.0.0.1" port=8020]   
//Context ctxconsole         ip [host="127.0.0.1" port=8042]
//Context ctxobserver        ip [host="127.0.0.1" port=8020]    
 
ExternalQActor basicrobot context ctxbasicrobot  
 
QActor boundaryqak30 context ctxboundaryqak30{    
[# var NumStep     = 0 #]  

	State s0 initial {
		[# NumStep     = 0; #] 
		updateResource [# "waitingOn( edge_$NumStep )" #] 
 	}
	Transition t0  whenMsg init -> coverNextEdge
	

	State coverNextEdge{  		  
   		delay 500 
 		updateResource [# "doingastep" #] 
     	request basicrobot -m step : step(350)	
	}
	Transition t0  whenReply stepdone -> coverNextEdge   
				   whenReply stepfail -> otherEdge
				   whenInterrupt stop -> handleStop
	  			   
 
	State otherEdge{  	
		[# NumStep = NumStep + 1 #]
		println("otherEdge")
 		updateResource [# "covering( edge_$NumStep)" #] 
   		forward basicrobot -m cmd : cmd(l)
	}	
	Goto coverNextEdge if [# NumStep < 4 #] else endOfWork

  	State handleStop{
  		printCurrentMessage
  		updateResource [# "stopped" #]
  	}
  	Transition t0 whenMsg resume -> exitFromStop
  	
  	State exitFromStop{
   		updateResource [# "resumed" #]
  		returnFromInterrupt
  	}
 	 
	State endOfWork{  		 
		updateResource [# "athomeagain" #] 
   		printCurrentMessage
	}	
	Goto s0
}

/*
 * Console
 */
QActor cmdconsole context ctxboundaryqak30 { //ctxconsole ctxboundaryqak30{
[# var N=0 #]
	State s0 initial{
		[# consolegui.StartStopGui( "boundaryqak30", 8032 ) #]
	}
	Goto alarmSimulation
	
	State alarmSimulation{
		delay 2000
		emit alarm : alarm($N)
		[# N = N+1 #]
	}
	Goto alarmSimulation
}

/*
 * Observer
 */
 QActor anobserver context ctxboundaryqak30 { //ctxobserver ctxboundaryqak30{
 	State s0 initial{
		observeResource boundaryqak30
	} 
	Transition t0 whenMsg coapUpdate -> handleUpdate
 	State handleUpdate{
		onMsg (coapUpdate : coapUpdate(RESOURCE, VALUE)) {
  		    [# MsgUtil.outgreen("anobserver OBSERVES: ${payloadArg(1)} FROM ${payloadArg(0)} ") #]
		}
	}
	Transition t0 whenMsg coapUpdate -> handleUpdate
 
 } 
 
QActor applobserver context ctxboundaryqak30 { //ctxobserver ctxboundaryqak30{
 	State s0 initial{
		observeResource boundaryqak30
	} 
	Transition t0 whenMsg coapUpdate -> handleUpdate
	              whenEvent alarm -> handleAlarm
	
	State handleUpdate{
		onMsg (coapUpdate : coapUpdate(RESOURCE, VALUE)) {
  		    [# MsgUtil.outgreen("applobserver OBSERVES: ${payloadArg(1)} FROM ${payloadArg(0)} ") #]
		}
	}
	Transition t0 whenMsg coapUpdate -> handleUpdate
	              whenEvent alarm -> handleAlarm
	
	State handleAlarm{
		onMsg (alarm : alarm(X)) {
  		    [# MsgUtil.outmagenta("applobserver handles ALARM: ${payloadArg(0)}") #]
		}
	}
	Transition t0 whenMsg coapUpdate -> handleUpdate
	              whenEvent alarm -> handleAlarm
	
 }
 
