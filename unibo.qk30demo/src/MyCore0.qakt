System tf22 
 
Request depositrequest : depositrequest(MATERIAL, TRUCKLOAD)
Reply loadaccept       : loadaccept(MATERIAL, TRUCKLOAD)
Reply loadrejected     : loadrejected(MATERIAL, TRUCKLOAD)
  
Request pickup         : pickup(MATERIAL, TRUCKLOAD)
Reply   pickupanswer   : pickupanswer( RESULT )

Request  gotobox       : gotobox(BOX,TRUCKLOAD)
Reply atbox            : atbox(BOX)
 
Dispatch stop          : stop(ARG)
Dispatch resume        : resume(ARG)
 
Dispatch coapUpdate    : coapUpdate(RESOURCE, VALUE)   // Lenzi - generated by  CoapObserverSupport

Event pickupdone       : pickupdone(ARG)

Event  alarm           : alarm(X)
Event  resume          : resume(X)

/* Messages for basicrobot */
Dispatch cmd        : cmd(MOVE) 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V) 
Reply   stepfail   : stepfail(DT, REASON)

Context ctxdriver       ip [ host="127.0.0.1" port=8040 ]
Context ctxwasteservice ip [ host="localhost" port=8013 ]
Context ctxbasicrobot   ip [ host="127.0.0.1" port=8020 ]
Context ctxrasp         ip [ host="127.0.0.1" port=8070 ]

ExternalQActor basicrobot context ctxbasicrobot

QActor wasteservice context ctxwasteservice {
			[#
				lateinit var Material  : String //glass, plastic
				lateinit var TruckLoad : String  
		 		
				lateinit var TrolleyPos : String   //gbox,pbox,Home,indoor,other
			#] 
	State s0 initial { 
		//[# org.apache.log4j.BasicConfigurator.configure() #]
		//https://sematext.com/blog/slf4j-tutorial/
		[# TrolleyPos = "home" #]
		updateResource [# "trolleyPos(home)" #]  
		println("the wasteservice is waiting ... ")
	}
	Transition t0 whenRequest depositrequest -> handlerequest
	
	State handlerequest{ 
		[# fun checkdepositpossible(MATERIAL:String,LOAD:String) : Boolean { return true } #]
		printCurrentMessage
		//updateResource [# "trolleyPos(home)" #]
		onMsg(depositrequest : depositrequest(MATERIAL, TRUCKLOAD)) {
			[#
				 Material 	= payloadArg(0) ;
				 TruckLoad 	= payloadArg(1) ;
			#]
			if[# checkdepositpossible( Material, TruckLoad ) #]{
				request transporttrolley -m pickup : pickup($Material,$TruckLoad)
			} else{  
				replyTo depositrequest with loadrejected : loadrejected($Material,$TruckLoad)
			}		
		}
	}
	Transition t0 whenReply pickupanswer -> handlepickupanswer
	   
	State handlepickupanswer{ 
		printCurrentMessage
		onMsg( pickupanswer : pickupanswer( RESULT ) ){
			[# var R = payloadArg(0); #]
			if [# R == "done" #] {
				//TODO
				[# TrolleyPos = "Indoor" #]
				//emit  ...
				updateResource [# "trolleyPos(indoor)" #]
				replyTo depositrequest with loadaccept : loadaccept($Material,$TruckLoad)
				/* JUST TO SHOW an event in the picture ...  */
				//delay 500 
		        emit pickupdone : pickupdone(ok) 
		        /* INTERACT WITH THE TROLLEY : execute a macro-move*/
		        request transporttrolley -m gotobox : gotobox($Material,$TruckLoad)
			}else{
				println("FATAL ERROR")
				replyTo depositrequest with 
				    loadrejected : loadrejected($Material,$TruckLoad)
			}
		}
	}
	//Goto dodeposit
	Transition t0 whenTime 5000   -> chackState
	              whenReply atbox -> dodeposit
	
	State chackState{
		printCurrentMessage
		[# unibo.comm22.utils.ColorsOut.outerr("chackState") #]
	}
	State dodeposit{
		//We suppose here that the service drives  the Trolley  to do the deposit
		//At the end the Trolley must be in the box related to the Material
		//delay 1000
		//request transporttrolley -m gotobox : gotobox("","")
		println("the transporttrolley is doing DODEPOSIT..")
		if [# Material == "glass" #]{ updateResource [# "trolleyPos(gbox)" #]
		}else{ updateResource [# "trolleyPos(pbox)" #] }

	}
	Transition t0 whenTime 5000  -> s0
}

QActor transporttrolley context ctxwasteservice {
	[# var InterruptedState = "none" #]
	State s0 initial {
		println("the transporttrolley is waiting..")
		[#  InterruptedState = "s0" #]
	}
	Transition t0 whenRequest pickup  -> doPickup
	              whenRequest gotobox -> tobox
	              whenInterrupt stop  -> handleStop 
	
	
	State doPickup{
		println("the transporttrolley is doing pickup ..")
		updateResource [# "trolleyDoing(pickup)" #]
		request basicrobot -m step : step(350)
		[#  InterruptedState = "doPickup" #]
		//delay 350
	}
	Transition t0 whenReply stepdone -> doPickup
                  whenReply stepfail -> atInput
 		          whenInterrupt stop -> handleStop 
	
	State atInput{
		updateResource [# "trolleyDone(pickup)" #]
		replyTo pickup with pickupanswer : pickupanswer( done )		
	}
	Goto s0
	
	State tobox{
		printCurrentMessage
		updateResource [# "trolleyDoing(tobox)" #]
		println("GOING TO BOX doing steps")
		[#  InterruptedState = "tobox" #]
		request basicrobot -m step : step(350)
	}
	Transition t0 whenTime 3000      -> answerlost  
	              whenReply stepdone -> tobox
                  whenReply stepfail -> obstacle
 		          whenInterrupt stop -> handleStop 
	
	State obstacle{
		printCurrentMessage
		[# unibo.comm22.utils.ColorsOut.outerr("obstacle") #]
		//replyTo gotobox with atbox : atbox(home)
		forward basicrobot -m cmd : cmd(l)
	}	
	Goto tobox        
	                
    State answerlost{
		[# unibo.comm22.utils.ColorsOut.outerr("answerlost") #]
    	
    } 
/*
 * Interrupt
 */
	State handleStop{
		[# unibo.comm22.utils.ColorsOut.outerr("interrupted in $InterruptedState") #]
		forward basicrobot -m cmd : cmd(h)
	}
	Transition t0 whenMsg resume     -> resumeFromStop
	              //whenInterrupt stop -> resumeFromStop  //interrupt nesting (runtime error)
	State resumeFromStop{
		[# unibo.comm22.utils.ColorsOut.outappl("resume to $InterruptedState", unibo.comm22.utils.ColorsOut.BLUE) #]
		printCurrentMessage
		returnFromInterrupt
	}
 

}

/* 
QActor anobserver context ctxwasteservice {
	State s0 initial {
		//observe wasteservice:
		//qrun coapObserverUtil.startObserving(myself, "wasteservice")
		//[# unibo.tf22.CoapObs(myself, "localhost", "8013", "ctxwasteservice", "wasteservice") #]
		//[# CoapObserverSupport(myself, "localhost", "8013", "ctxwasteservice", "wasteservice") #]
//	    observeResource wasteservice
//	    observeResource transporttrolley
	} 
	Goto idle
	
	State idle {
		println("observer waiting..")
	}
	Transition t0 whenMsg coapUpdate -> handleUpdate
 
	State handleUpdate {
		printCurrentMessage
		onMsg (coapUpdate : coapUpdate(RESOURCE, VALUE)) {
			//println("FROM ${payloadArg(0)} OBSERVED: ${payloadArg(1)}")
			[# unibo.comm22.utils.ColorsOut.out("anobserver FROM ${payloadArg(0)} OBSERVES: ${payloadArg(1)}", unibo.comm22.utils.ColorsOut.BLUE) #]
		}
	} 
	Goto idle
}
*/
	
/*
 * SIMULATION

QActor alarm context ctxwasteservice {
	State s0 initial {
		println("alarm")
		        delay 400
 				println("-------------- STOP after 400 ")
				forward transporttrolley -m stop : stop(at400)
 				delay 1000
 				println("-------------- RESUME after 400 ")
 				forward transporttrolley -m resume : resume(at400)	
				 
				delay 1500				
				println("-------------- STOP after 1500 ")
				forward transporttrolley -m stop : stop(at1500)
				delay 1000
				forward transporttrolley -m resume : resume(at1500)	
//				delay 200
//				println("stop a2")
//				forward transporttrolley -m stop : stop(a2)
//				delay 1000
//				forward transporttrolley -m resume : resume(a2)	
		
		        // SIMULATE AN INTERRUPT 
	 
		        //Forward a stop after 0.5 secs
		        delay 400
		        forward transporttrolley -m stop : stop(a1)
				delay 1500
 		        //forward transporttrolley -m stop : stop(a2)  //interrupt nesting (run time error)
				//After a while resume ...	
				forward transporttrolley -m resume : resume(1)	
				// SIMULATE ANOTHER INTERRUPT 	
				delay 500
				forward transporttrolley -m stop : stop(2)
				//After a while resume ...	
				delay 1500
				forward transporttrolley -m resume : resume(2)	
				//End SIMULATE AN INTERRUPT 
				
				// SIMULATE A DEFINITIVE stop	
				delay 1500
				forward transporttrolley -m stop : stop(final)
				  

	}
	
}
 */

QActor driver context ctxdriver {
	State s0 initial {
		println("driver")
		request wasteservice -m depositrequest :  depositrequest(glass,22)
	}
	Transition t0 whenReply loadaccept -> handleAccept
	
	State handleAccept{
		printCurrentMessage
 	}
	Transition  t0 whenEvent pickupdone -> workdone   //just to use some event ...
	
	State workdone{
		printCurrentMessage
	}
}

QActor sonaronrasp context ctxrasp{
	State s0 initial {
		emit alarm : alarm(distance)
		emit resume : resume(1)
	}
}
